// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "..\stdafx.h"
#include "CashRecyclerWrapper.h"
#include "GloryOPOS.h"
#include "SafePayAPI.h"
#include "SafePayC.h"

#define COMP_ID ID_DM               
#define T_ID _T("CashRecyclerWrapper")
long CCashRecyclerWrapper::m_nDeposited = 0;		// TAR 311471
long CCashRecyclerWrapper::m_nDispensed = 0;		// TAR 311471
bool CCashRecyclerWrapper::m_bPauseCount = false;	// TAR 311471
bool CCashRecyclerWrapper::m_bDepositState = false; // TAR 311332
long CCashRecyclerWrapper::m_nCurrentDeposit = 0;

/////////////////////////////////////////////////////////////////////////////
// CCashRecyclerWrapper

//  StrToken
//
// Purpose: Pull tokens from a CString ( see strtok )
// Notes:   This is a more restrictive version than was used in the 
//          Cash Acceptor Service Object and is better. 

static CString StrToken( 
   CString& sData,
   LPCTSTR  sDelimiter )
   {
   CString sToken = sData.SpanExcluding( sDelimiter );
   sData = sData.Mid( sToken.GetLength() );
   if ( sData.IsEmpty() == FALSE )
      sData = sData.Mid( 1 );
   sToken.TrimLeft();
   sToken.TrimRight();
   return sToken;
   }

// BuildCashListString
//
// Purpose: Add amount to string. (ExitCashList, CurrencyCashList, etc.)

static void BuildCashListString( 
	CString& sResult,
	DWORD    nUnit )
	{
	CString sTemp;
	sTemp.Format(_T("%ld"), nUnit );
	if ( sResult.IsEmpty() == FALSE )
		sResult += _T(",");
	sResult += sTemp;
	return;
	}


// ReadCashCountFromString
//
// Purpose: Pull next unit:count from the sData string

static BOOL ReadCashCountFromString(
	CString&		sData,
	DWORD*		nUnit,
	long*		   nCount )
	{
	BOOL bResult = FALSE;
	if ( _stscanf( sData, _T("%ld:%ld,"), nUnit, nCount ) == 2 )
		{
		CString sTemp;
		sTemp.Format( _T("%ld:%ld,"), *nUnit, *nCount );
      StrToken( sData, _T(",") );
		bResult = TRUE;
		}
	return bResult;
	}

// BuildCashCountString
//
// Purpose: Add nUnit and nCount to sResult.  
// Note:    Does not detect duplicate units.

static void BuildCashCountString( 
	CString& sResult,
	DWORD		nUnit,
	long		nCount )
	{
	CString sTemp;
	sTemp.Format(_T("%ld:%ld"), nUnit, nCount );
	if ( sResult.IsEmpty() == FALSE )
		sResult += _T(",");
	sResult += sTemp;
	return;
	}


// PluckSpecificTotal
//
// Purpose: Pick a count segment "x:y" where x is nDispenseUnit and y is returned
//          in nDispenseCount.
//          The "x:y" is removed from the string so that it cannot be found again.

static BOOL PluckSpecificTotal( 
   CString& sTotals, 
   DWORD    nDispenseUnit, 
   long*    nDispenseCount )
   {
	CString sCheck;
   BOOL bResult = FALSE;
   CString sResult;
   while ( sTotals.IsEmpty() == FALSE )
      {
      DWORD nThisUnit = 0;
      long  nThisCount = 0;
		VERIFY( ReadCashCountFromString( sTotals, &nThisUnit, &nThisCount ) != FALSE );
      if ( nThisUnit == nDispenseUnit )
         {
         // Should not have been found before in this string, this is changer totals!
         ASSERT( bResult == FALSE );
         bResult = TRUE;
         *nDispenseCount = nThisCount;
         }
      else  // Put this unit back in the string!
         BuildCashCountString( sResult, nThisUnit, nThisCount );
      }
   sTotals = sResult;
   return bResult;
   }



BOOL CCashRecyclerWrapper::Create( 
   CWnd* pParentWnd, 
   UINT nID )
	{
	return CreateControl( GetClsid(), NULL, 0, CRect(0,0,0,0), pParentWnd, nID );
   }

/////////////////////////////////////////////////////////////////////////////
// CCashRecyclerWrapper properties

/////////////////////////////////////////////////////////////////////////////
// CCashRecyclerWrapper operations



long CCashRecyclerWrapper::DirectIO(long Command, long* pData, BSTR* pString)
{
	long result;
        result = TOPOSCashChanger<CGenericOposIF>::DirectIO(Command, pData, pString);
	return result;
}

/**
 * Note:  Added overload to handle the case where the SafePay cash recycler is
 *        powered down in the middle of a FL transaction.
 *
 *        Raw GetResultCodeExtended() returned OPOS_SUCCESS in this case which
 *        caused DMCheckHealth to return OPOS_SUCCESS as well.
 */
long CCashRecyclerWrapper::GetResultCodeExtended()
{
	long result = 0;
    BSTR pString = NULL;
    CString csTemp;
    long rc = 0;

	trace(L6, _T("+GetResultCodeExtended"));
	result = TOPOSCashChanger<CGenericOposIF>::GetResultCodeExtended();

	// For the SafePay recycler, if extended result code is zero, then examine
	// the error status bits.
	if(m_ModelID == DEVID_SAFEPAY && result == OPOS_SUCCESS)
	{
		trace(L4, _T("GetResultCodeExtended returned 0.  Examining status bits"));
		
		try
		{
			pString = csTemp.AllocSysString();
			rc = DirectIO(SP_DIO_GETJAMREASON, &result, &pString);
			SysFreeString(pString);
			pString = NULL;

			if(rc != OPOS_SUCCESS)
			{
				trace(L4, _T("DirectIO FAILED with rc=%d.  Assigning rc as extended result code."), rc);
				result = rc;
			}
		}
		catch(CMemoryException *me)
		{
			trace(L4, _T("-GetResultCodeExtended  ERROR:  CMemoryException thrown!  Returning %d"), result);
			me->Delete();
			return result;
		}
		catch(...)
		{
			if(pString)
			{
				SysFreeString(pString);
			}
			trace(L4, _T("-GetResultCodeExtended ERROR:  DirectIO FAILED.  Returning %d"), result);
			return result;
		}
	}

	trace(L6, _T("-GetResultCodeExtended> result: %d"), result);
	return result;
}

long CCashRecyclerWrapper::DispenseCash(LPCTSTR CashCounts)
{
	long lResult = BeginDispense();
   if ( lResult == OPOS_SUCCESS )
      {
      lResult = TOPOSCashChanger<CGenericOposIF>::DispenseCash( CashCounts );
      }
   ASSERT( lResult == OPOS_SUCCESS );
   if ( lResult == OPOS_SUCCESS )
      {
     //GetDispensedCashList() causes delay in CashRecycler, if return value is OPOS_SUCCESS,
	// it means dispensing is successfully

      CString sDispensed = GetDispensedCashList( );
      while ( sDispensed.IsEmpty() != FALSE )
         {
         Sleep( 1000 );
         sDispensed = GetDispensedCashList( );
         }
      StrToken( sDispensed, _T(";") );
      if ( sDispensed.IsEmpty() == FALSE ) 
         mo.PostDM(DM_STATUS, DMCLASS_CASHCHANGER, m_nDeviceId, DM_CC_STATUS_BILLS_TAKEN, NULL);
      }
	return lResult;
}

long CCashRecyclerWrapper::DispenseChange(long Amount)
{
	long lResult = BeginDispense();
   if ( lResult == OPOS_SUCCESS )
      {
      lResult = TOPOSCashChanger<CGenericOposIF>::DispenseChange( Amount );
      }
  // ASSERT( lResult == OPOS_SUCCESS );
   if ( lResult == OPOS_SUCCESS )
      {
      //GetDispensedCashList() causes delay in CashRecycler, if return value is OPOS_SUCCESS,
	// it means dispensing is successfully

	   CString sDispensed = GetDispensedCashList( );
      while ( sDispensed.IsEmpty() != FALSE )
         {
         Sleep( 1000 );
         sDispensed = GetDispensedCashList( );
         }
      StrToken( sDispensed, _T(";") );
      if ( sDispensed.IsEmpty() == FALSE )
         mo.PostDM(DM_STATUS, DMCLASS_CASHCHANGER, m_nDeviceId, DM_CC_STATUS_BILLS_TAKEN, NULL);
      }
	return lResult;
}

long CCashRecyclerWrapper::ReadCashCounts(BSTR* pCashCounts, BOOL* pDiscrepancy)
{
	CString sCoinResult;
	CString sNoteResult;
	CString sNotePart;
	long lResult = ReadCashCountsInternal( sNotePart );
	trace(L7, _T("ReadCashCounts sNotePart %s"), sNotePart);
	if ( lResult == OPOS_SUCCESS )
	{
		CString sCoinPart = StrToken( sNotePart, _T(";") );
		for ( int nIndex = 0; nIndex < m_aDispenseCoins.GetSize(); nIndex++ )
		{
			TClassPtr<CCashDispenseUnit> pUnit = m_aDispenseCoins.GetAt( nIndex );
			long nCount = 0;
			VERIFY( PluckSpecificTotal( sCoinPart, pUnit->m_dwUnit, &nCount ) != FALSE );
			BuildCashCountString( sCoinResult, pUnit->m_dwUnit, nCount );
		}
		for ( nIndex = 0; nIndex < m_aDispenseNotes.GetSize(); nIndex++ )
		{
			TClassPtr<CCashDispenseUnit> pUnit = m_aDispenseNotes.GetAt( nIndex );
			long nCount = 0;

			VERIFY( PluckSpecificTotal( sNotePart, pUnit->m_dwUnit, &nCount ) != FALSE );
			BuildCashCountString( sNoteResult, pUnit->m_dwUnit, nCount );
		}
		sCoinResult += _T(";");
		sCoinResult += sNoteResult;
		::SysFreeString( *pCashCounts );
		trace(L7, _T("ReadCashCounts sCoinResult %s"), sCoinResult);
		*pCashCounts = sCoinResult.AllocSysString();
	}
	return lResult;
}

long CCashRecyclerWrapper::ReadDropBoxCounts(
   BSTR* pCashCounts, 
   BOOL* pDiscrepancy )
   {
   CString sCoinResult;
   CString sNoteResult;
   CString sNotePart;
   long lResult = ReadCashCountsInternal( sNotePart );
   trace(L7, _T("ReadDropBoxCounts sNotePart %s"), sNotePart);
   if ( lResult == OPOS_SUCCESS )
      {
      CString sCoinPart = StrToken( sNotePart, _T(";") );
      for ( int nIndex = 0; nIndex < m_aDispenseCoins.GetSize(); nIndex++ )
         {
         TClassPtr<CCashDispenseUnit> pUnit = m_aDispenseCoins.GetAt( nIndex );
         long nCount = 0;
         VERIFY( PluckSpecificTotal( sCoinPart, pUnit->m_dwUnit, &nCount ) != FALSE );
         }
      sCoinResult = sCoinPart; // Use what is left
      for ( nIndex = 0; nIndex < m_aDispenseNotes.GetSize(); nIndex++ )
         {
         TClassPtr<CCashDispenseUnit> pUnit = m_aDispenseNotes.GetAt( nIndex );
         long nCount = 0;
         VERIFY( PluckSpecificTotal( sNotePart, pUnit->m_dwUnit, &nCount ) != FALSE );
         }
      sNoteResult = sNotePart;
      sCoinResult += _T(";");
      sCoinResult += sNoteResult;
      ::SysFreeString( *pCashCounts );
      *pCashCounts = sCoinResult.AllocSysString();
      }
	return lResult;
   }

/**
 * Function:        ReadStatusBits
 * Purpose:         Retrieves SafePay error status bits from device.  Different bits
 *                  indicate different errors (see SP_Status class in SafePayAPI.h)
 * Parameters:      pData - Receives the status bit values.
 * Returns:         true if successful.
 * Calls:           
 * Side Effects:
 * Notes:           Only valid for the SafePay cash recycler.   
 */
bool CCashRecyclerWrapper::ReadStatusBits(long &pData)
{
    pData = 0;
    BSTR pString = NULL;
    CString csTemp;
    long rc;

    ASSERT(m_ModelID == DEVID_SAFEPAY); 
    if(m_ModelID != DEVID_SAFEPAY)
    {
        return false;
    }

    try
    {
        pString = csTemp.AllocSysString();
        rc = DirectIO(SP_DIO_SAFEPAY_STATUS, &pData, &pString);
        SysFreeString(pString);
        pString = NULL;
    }
    catch(CMemoryException *me)
    {
        trace(L4, _T("  ERROR:  CMemoryException thrown!  Returning false"));
        me->Delete();
        return false;
    }
    catch(...)
    {
        if(pString)
        {
            SysFreeString(pString);
        }
        trace(L4, _T("  ERROR:  DirectIO FAILED.  Returning false"));
        return false;
    }

    if(rc != OPOS_SUCCESS)
    {
        trace(L4, _T("  ERROR:  DirectIO FAILED.  rc = %d"), rc);
        return false;
    }
    return true;
}

/**
 * Function:        IsUrgentMessagePending
 * Purpose:         Indicates whether there are pending SafePay urgent messages
 *                  to be displayed.
 * Parameters:      NONE
 * Returns:         true if a message is available, false if error or no message
 *                  is available..
 * Calls:           
 * Side Effects:
 * Notes:               
 */
bool CCashRecyclerWrapper::IsUrgentMessagePending(void)
{
    SP_Status st;
    long pData;

    ASSERT(m_ModelID == DEVID_SAFEPAY); 
    if(m_ModelID != DEVID_SAFEPAY)
    {
        return false;
    }

    if(! ReadStatusBits(pData))
    {
        return false;
    }

    st = pData;
    return(st.CheckHealth);
}

/**
 * Function:        RetrieveUrgentMessage
 * Purpose:         Obtain the SafePay error message (if any) from the device SO.
 * Parameters:      msg (in) - Receives the ugent message.
 * Returns:         OPOS_SUCCESS if successful.  
 * Calls:           
 * Side Effects:
 * Notes:                   
 */
#define UMSG_BUFFSZ 512
BYTE ubuff[UMSG_BUFFSZ];
long CCashRecyclerWrapper::RetrieveUrgentMessage(CString &msg)
{
    trace(L6, _T("+RetrieveUrgentMessage"));
    long pData = 0;
    BSTR pString = NULL;
    long rc = OPOS_SUCCESS;

    ASSERT(m_ModelID == DEVID_SAFEPAY);
    if(m_ModelID != DEVID_SAFEPAY)
    {
        return OPOS_E_ILLEGAL;
    }

    memset(ubuff, 0, UMSG_BUFFSZ);      // Start with a clean buffer.
    msg = _T("");                       // Clear out message parameter.
    try
    {
        pString = msg.AllocSysString();
        pData = (long)(&ubuff);
        rc = DirectIO(SP_DIO_SAFEPAY_MESSAGE, &pData, &pString);
        SysFreeString(pString);
        pString = NULL;
    }
    catch(CMemoryException *me)
    {
        trace(L4, _T("ERROR:  CMemoryException thrown!  Returning OPOS_E_FAILURE"));
        me->Delete();
        return OPOS_E_FAILURE;
    }
    catch(...)
    {
        if(pString)
        {
            SysFreeString(pString);
        }
        trace(L4, _T("ERROR:  DirectIO FAILED.  Returning OPOS_E_FAILURE"));
        return OPOS_E_FAILURE;
    }

    if(rc != OPOS_SUCCESS)
    {
        trace(L4, _T("ERROR:  DirectIO FAILED.  rc = %d"), rc);
        return rc;
    }

    // The SafePay urgent message is UTF-8.  If UNICODE, then convert to UCS-2
    // (UTF-16).
#ifdef UNICODE
    LPTSTR dbuff = msg.GetBuffer(UMSG_BUFFSZ);
    rc = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)ubuff, -1, dbuff, UMSG_BUFFSZ);

    if(rc == 0)  // Conversion failed.
    {
        trace(L4, _T("ERROR:  MultiByteToWideChar FAILED.  rc = %d"),GetLastError());
        rc = OPOS_E_FAILURE;
    }
    else
    {
        rc = OPOS_SUCCESS;
    }

    dbuff[UMSG_BUFFSZ - 1] = _T('0');       // Make sure string is NULL terminated.
    msg.ReleaseBuffer();
#else
    msg = ubuff;
#endif

    trace(L6, _T("-RetrieveUrgentMessage> rc: %d; msg: %s"), rc, (LPCTSTR)msg);
    return rc;
}

/**
 * Function:        UnlockNoteCover
 * Purpose:         Unlock SafePay note cover.  This can only be done through
 *                  software.
 * Parameters:      NONE
 * Returns:         OPOS_SUCCESS if successful.  SO error code otherwise.
 * Calls:           
 * Side Effects:
 * Notes:               
 */
long CCashRecyclerWrapper::UnlockNoteCover(void)
{
    long pData = 0;
    BSTR pString = NULL;
    CString csTemp;
    long rc = OPOS_SUCCESS;

    ASSERT(m_ModelID == DEVID_SAFEPAY); 
    if(m_ModelID != DEVID_SAFEPAY)
    {
        return OPOS_E_ILLEGAL;
    }

    try
    {
        pString = csTemp.AllocSysString();
        rc = DirectIO(SP_DIO_OPEN_COVER, &pData, &pString);
        SysFreeString(pString);
        pString = NULL;
    }
    catch(CMemoryException *me)
    {
        trace(L4, _T("ERROR:  CMemoryException thrown!  Returning OPOS_E_FAILURE"));
        me->Delete();
        return OPOS_E_FAILURE;
    }
    catch(...)
    {
        if(pString)
        {
            SysFreeString(pString);
        }
        trace(L4, _T("ERROR:  DirectIO FAILED.  Returning OPOS_E_FAILURE"));
        return OPOS_E_FAILURE;
    }
    return rc;
}

long CCashRecyclerWrapper::GetDepositAmount(bool bRaw)
{
	long result;
        result = TOPOSCashChanger<CGenericOposIF>::GetDepositAmount();
	trace(L6, _T("+GetDepositAmount() - result: %d; m_nDeposited: %d; m_nDispensed: %d"),
		result, m_nDeposited, m_nDispensed);

	// TAR 311471 - Begin
	if(bRaw)
	{
		return result;
	}

	return result + m_nDeposited - m_nDispensed;
	// TAR 311471 - End
}

long CCashRecyclerWrapper::BeginDeposit()
{
	trace(L6, _T("+BeginDeposit"));
	long result = OPOS_SUCCESS;
	
	// Don't try to begin deposit again if we are already accepting deposits.
	if(m_bDepositState == true)		// TAR 313343
	{
		trace(L6, _T("-BeginDeposit:  Already in deposit state"));
		return result;
	}
	
	SetDataEventEnabled( TRUE );
        result = TOPOSCashChanger<CGenericOposIF>::BeginDeposit( );
	
	// device could be busy, try to enable the device every co.getTimeOutGloryUnitDispense() msec. 
	// wait for up to nOperationsGloryDispenseRetries*co.getTimeOutGloryUnitDispense() msecs.
	int n = 0;   
	SMStateBase::fRecyclerNotReady = false; //dp185016 Recycler Platform Issue #12
	// TAR 312713 - Added nOperationsGloryDispenseRetries and co.getTimeOutGloryUnitDispense()
	while(result == OPOS_E_EXTENDED && n< co.nOperationsGloryDispenseRetries)
	{
		if(GetResultCodeExtended() == OPOS_ECHAN_CASSETTEWAIT
			|| GetResultCodeExtended() == OPOS_ECHAN_BUSY ) //dp185016 Recycler Platform Issue #12
		{
			Sleep(co.getTimeOutGloryUnitDispense());
			InvokeHelper(0x49, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
			n++;
		}
		else
			break;
		
	}
	
	if (co.nOperationsGloryDispenseRetries == n)
	{
		SMStateBase::fRecyclerNotReady = true; //dp185016 Recycler Platform Issue #12
	}
      m_mapDepositCoins.RemoveAll();
      m_mapDepositNotes.RemoveAll();
	// TAR 311332
	if(result == OPOS_SUCCESS)
	{
		m_bDepositState = true;

		// The DepositAmount property is reset when BeginDeposit() is called.
		if(!m_bPauseCount)
		{
			m_nDeposited += m_nCurrentDeposit;
		}		
		m_nCurrentDeposit = 0;		
	}
	// TAR 311332

	trace(L6, _T("-BeginDeposit() - Saved amount: %d; Dispensed amount: %d"), 
		m_nDeposited, m_nDispensed);

	return result;
}

long CCashRecyclerWrapper::EndDeposit(long Success)
{
	long result = OPOS_SUCCESS;
	long rc;
	
	// Don't try to end deposit if this has already been done.
	if(m_bDepositState == false)	// TAR 313343
	{
		trace(L6, _T("+EndDeposit:  Not in deposit state.  EndDeposit not necessary."));
		return result;
	}
	FixDeposit();
    result = TOPOSCashChanger<CGenericOposIF>::EndDeposit( Success );

	ProcessNotes();

	// TAR 311332
	if(result == OPOS_SUCCESS)
	{
		m_bDepositState = false;
	}
	else
	{
		rc = GetDepositStatus();
		trace(L6, _T("EndDeposit:  FAILED rc=%d;  GetDepositStatus returned rc=%d"), 
			result, rc);

		// If there is a device error, the device may already be out
		// of deposit mode.  If so, then update internal tracking variable.
		if(rc != CHAN_STATUS_DEPOSIT_START)
		{
			trace(L6, _T("EndDeposit: Device is not in deposit mode."));
			m_bDepositState = false;
			// result = OPOS_SUCCESS;
		}
	}
	// TAR 311332
	return result;
}

long CCashRecyclerWrapper::FixDeposit()
{
	long result;
        result = TOPOSCashChanger<CGenericOposIF>::FixDeposit();
	trace(L6, _T("+FixDeposit() Current Amount: %d; Saved amount: %d; Dispensed amount: %d"), 
		m_nCurrentDeposit, m_nDeposited, m_nDispensed);

	if(result==OPOS_SUCCESS)
	{
		if(! m_bPauseCount)
		{
			m_nCurrentDeposit = GetDepositAmount(true);
		}

	}
	else
	{
		trace(L4, _T("-FixDeposit():  ERROR rc=0x%X"), result);
		return result;
	}

	trace(L6, _T("-FixDeposit() Current Amount: %d; Saved amount: %d; Dispensed amount: %d"), 
		m_nCurrentDeposit, m_nDeposited, m_nDispensed);
	return result;
}
/**
 * Function:        ResetCounts
 * Purpose:         Resets tracking variables.
 * Parameters:      NONE
 * Returns:         NONE
 * Calls:           
 * Side Effects:
 * Notes:           Created for TAR 311471.
 */
void CCashRecyclerWrapper::ResetCounts(void)
{
	m_nDeposited = 0;
	m_nDispensed = 0;
	m_bPauseCount = false;
	m_nCurrentDeposit = 0;
}

/**
 * Function:        UpdateDispensed
 * Purpose:         Increments m_nDispensed with latest successful dispense
 *                  amount.
 * Parameters:      nDisp - Amount that was dispensed.
 * Returns:         NONE
 * Calls:           
 * Side Effects:
 * Notes:           Created for TAR 311471.
 */
void CCashRecyclerWrapper::UpdateDispensed(long nDisp)
{
    if(! m_bPauseCount)
    {
        trace(L6, _T("+UpdateDispensed(%d):  m_nDispensed=%d"), nDisp, m_nDispensed);
        m_nDispensed += nDisp;
    }
}

/**
 * Function:        PauseCounts
 * Purpose:         Stop or resume tracking of deposit and dispensed values.
 * Parameters:      bPause - Resume tracking if true, stop tracking if false.
 * Returns:         NONE
 * Calls:           
 * Side Effects:
 * Notes:           Created for TAR 311471.  We do not want to track deposit
 *                  or dipsense in states such as cash management.
 */
void CCashRecyclerWrapper::PauseCounts(bool bPause)
{
    m_bPauseCount = bPause;
    m_nCurrentDeposit = 0;
}

/**
 * Function:        PauseCounts
 * Purpose:         Return the counting status.
 * Parameters:      NONE
 * Returns:         true if counts are paused.  false if counting is resumed.
 * Calls:           
 * Side Effects:
 * Notes:           
 */
bool CCashRecyclerWrapper::PauseCounts(void) const
{
    return m_bPauseCount;
}

/**
 * Function:        GetDepositState
 * Purpose:         Returns the deposit state of the recycler.
 * Parameters:      NONE
 * Returns:         true if BeginDeposit() has been called, false if EndDeposit()
 *                  has been called.
 * Calls:           
 * Side Effects:
 * Notes:           Previously tried using the SO GetDepositStatus(), but there
 *                  is a (undocumented) time lag between when BeginDeposit()
 *                  called and when GetDepositStatus() returns CHAN_STATUS_DEPOSIT_START.
 *                  See TAR 313343
 */
bool CCashRecyclerWrapper::GetDepositState()
{
    return m_bDepositState;
}

// CCashRecyclerWrapper::GetCurrencyContainerMap
//
// Purpose: Return ScotCashChanger property. 
// Note:    We use exit cash list because FastLane expects only one exit. 
//          Also the Glory CurrencyCashList property includes the 2000 yen note which
//          is not dispensable - and so it shouldn't be included. 


CString CCashRecyclerWrapper::GetCurrencyContainerMap(
   void )
   {
   CString sCoinPart;

   for ( int nIndex = 0; nIndex < m_aDispenseCoins.GetSize(); nIndex++ )
      {
      TClassPtr<CCashDispenseUnit> pUnit = m_aDispenseCoins.GetAt( nIndex );
      pUnit->AddContainerMapString( sCoinPart );
      }
   CString sNotePart;
   for ( nIndex = 0; nIndex < m_aDispenseNotes.GetSize(); nIndex++ )
      {
      TClassPtr<CCashDispenseUnit> pUnit = m_aDispenseNotes.GetAt( nIndex );
      pUnit->AddContainerMapString( sNotePart );
      }
   return sCoinPart + _T(";") + sNotePart;
   }


long CCashRecyclerWrapper::BeginDispense(
   void )
   {
   if ( GetDepositStatus() != CHAN_STATUS_DEPOSIT_END)
      {
      EndDeposit( CHAN_DEPOSIT_NOCHANGE  );
      Sleep( 1000 );
      }
   CString sNotePart;
   CString sCode = GetCurrencyCode();
   long lResult = ReadCashCountsInternal( sNotePart );
   trace(L7, _T("BeginDispense sNotePart %s"), sNotePart);
   if ( lResult == OPOS_SUCCESS )
      {
      CString sCoinPart = StrToken( sNotePart, _T(";") );
      for ( int nIndex = 0; nIndex < m_aDispenseCoins.GetSize(); nIndex++ )
         {
         TClassPtr<CCashDispenseUnit> pUnit = m_aDispenseCoins.GetAt( nIndex );
         long nCount = 0;
         VERIFY( PluckSpecificTotal( sCoinPart, pUnit->m_dwUnit, &nCount ) != FALSE );
         pUnit->SetCurrentCount( nCount );
         }
      for ( nIndex = 0; nIndex < m_aDispenseNotes.GetSize(); nIndex++ )
         {
         TClassPtr<CCashDispenseUnit> pUnit = m_aDispenseNotes.GetAt( nIndex );
         long nCount = 0;
		 VERIFY( PluckSpecificTotal( sNotePart, pUnit->m_dwUnit, &nCount ) != FALSE );

         pUnit->SetCurrentCount( nCount );
         }
      }
   return lResult;
   }


CString CCashRecyclerWrapper::GetDispensedCashList( 
   void )
{
	// TAR 305026 - Use new DirectIO call to get dispensed list.
	CString sCoinResult = _T("");
	CString sNoteResult = _T("");
	CString csResult = _T(";");
	
	trace(L6, _T("+CCashRecyclerWrapper::GetDispensedCashList()"));

	switch(m_ModelID)
	{
	case DEVID_GLORY:
		BuildNoteDispenseStr(sNoteResult);
		BuildCoinDispenseStr(sCoinResult);
		csResult = sCoinResult + _T(";") + sNoteResult;
		break;
	case DEVID_SAFEPAY:
		GetRawCurrencyString(0x0, csResult);
		break;
	default:
		trace(L6, _T("  ERROR:  Unknown recycler model.  Cannot get dispense list."));
	}
	
	trace(L6, _T("-CCashRecyclerWrapper::GetDispensedCashList()"));
	
	return csResult;
}

/**
 * Function:        BuildCoinDispenseStr
 * Purpose:         Builds a string of the form 
 *                  denomination:count [, denomination:count]* for the coins that 
 *                  were last dispensed from the cash recycler.
 * Parameters:      csTarget (out) - Receives the newly constructed dispense
 *                      list string.
 * Returns:         Total currency amount of coins in the constructed string
 *                  or -1 if not successful.
 * Calls:           CCashRecyclerWrapper::GetRawCurrencyString()
 * Side Effects:
 * Notes:           Created for TAR 305026.
 *                  Internal method.
 */
long CCashRecyclerWrapper::BuildCoinDispenseStr(CString &csTarget)
{
	CString csRaw;					// Holds the RAW string returned by DirectIO() call.
	CString csTemp;
	int offset = 34+11;				// Offset into the RAW string where coin data resides.
	long rc = 0;					// Return code.
	TCHAR szCount[5] = _T("0x00");	// Values are in hex.
	TCHAR *szStop;					// Used in _tcstol().
	long lCount;					// Unit coin counts.

	trace(L7, _T("+CCashRecyclerWrapper::BuildCoinDispenseStr()"));
	if(GetRawCurrencyString(0x01, csRaw) == FALSE)
	{
		return -1;
	}

	trace(L6, _T("CCashRecyclerWrapper::BuildCoinDispenseStr()  RAW RESULT: %s"), csRaw);
	csTarget = _T("");

	for(int i=0; i<m_aCoinDenom.GetSize(); ++i)
	{
		szCount[3] = csRaw[offset--];
		szCount[2] = csRaw[offset--];

		lCount = _tcstol(szCount, &szStop, 16);

		if(lCount > 0)
		{
			csTemp.Format(_T(",%d:%d"), m_aCoinDenom[i], lCount);
			csTarget += csTemp;
			
			rc += lCount * m_aCoinDenom[i];
		}

		trace(L7, _T("  m_aCoinDenom[%d]: %5d; dispense count: %s [%d]"), 
			i, m_aCoinDenom[i], szCount, lCount);
	}

	csTarget.TrimLeft(_T(","));
	trace(L7, _T("-CCashRecyclerWrapper::BuildCoinDispenseStr()"));

	return rc;
}

/**
 * Function:        BuildNoteDispenseStr
 * Purpose:         Builds a string of the form 
 *                  denomination:count [, denomination:count]* for the bills that 
 *                  were last dispensed from the cash recycler.
 * Parameters:      csTarget (out) - Receives the newly constructed dispense
 *                      list string.
 * Returns:         Total currency amount of bills in the constructed string
 *                  or -1 if not successful.
 * Calls:           CCashRecyclerWrapper::GetRawCurrencyString()
 * Side Effects:
 * Notes:           Created for TAR 305026.
 *                  Could use m_aDispenseNotes, but 2000 yen is not always 
 *                  present.  Also, order of elements is not guaranteed, so a
 *                  internal array is used.
 *
 *                  Internal method.
 */
long CCashRecyclerWrapper::BuildNoteDispenseStr(CString &csTarget)
{
	CString csRaw;				// Holds the RAW string returned by DirectIO() call.
	CString csTemp;
	int offset = 24+15;			// Offset into the RAW string where coin data resides.
	long rc = 0;				// Return code.
	TCHAR szCount[7] = _T("0x0000");	
	TCHAR *szStop;				// Used in _tcstol().
	long lCount;				// Unit bill counts.

	trace(L7, _T("+CCashRecyclerWrapper::BuildNoteDispenseStr()"));
	if(GetRawCurrencyString(0x80, csRaw) == FALSE)
	{
		return -1;
	}

	trace(L6, _T("CCashRecyclerWrapper::BuildNoteDispenseStr()  RAW RESULT: %s"), csRaw);
	csTarget = _T("");

	for(int i=0; i<m_aNoteDenom.GetSize(); ++i)
	{
		szCount[5] = csRaw[offset--];
		szCount[4] = csRaw[offset--];
		szCount[3] = csRaw[offset--];
		szCount[2] = csRaw[offset--];

		lCount = _tcstol(szCount, &szStop, 16);

		if(lCount > 0)
		{
			csTemp.Format(_T(",%d:%d"), m_aNoteDenom[i], lCount);
			csTarget += csTemp;

			rc += lCount * m_aNoteDenom[i];
		}

		trace(L7, _T("  m_aNoteDenom[%d]: %5d; dispense count: %s [%d]"), 
			i, m_aNoteDenom[i], szCount, lCount);
	}

	csTarget.TrimLeft(_T(","));
	trace(L7, _T("-CCashRecyclerWrapper::BuildNoteDispenseStr()"));

	return rc;
}
	
/**
 * Function:        GetRawCurrencyString    
 * Purpose:         Retrieves the raw status string from the cash recycler.
 *                  This string can be parsed to retrieve the number of coins/notes
 *                  that were dispensed/deposited in the last operation.
 *                  
 * Parameters:      pData       - Read command to send to DirectIO() method.
 *                                Must be either 0x01 (coins) or 0x80 (bills).
 *                  csTarget    - Receives the raw string from DirectIO().
 * Returns:         TRUE if successful, FALSE otherwise.
 * Calls:           CCashRecyclerWrapper::DirectIO()
 *                  CString::AllocSysString()
 * Side Effects:    csTarget is only altered if TRUE is returned.
 * Notes:           Created for TAR 305026.
 *                  Internal method.        
 */
BOOL CCashRecyclerWrapper::GetRawCurrencyString(long pData, CString &csTarget)
{
	BSTR pString;
	CString csTemp = _T("");
	long rc;
	int cmd;

	trace(L7, _T("+CCashRecyclerWrapper::GetRawCurrencyString(%d)"), pData);

	switch(m_ModelID)
	{
	case DEVID_GLORY:
		if(pData != 0x01 && pData != 0x80)
		{
			return FALSE;
		}
		cmd = CHAN_DI_STATUSREAD;
		break;
	case DEVID_SAFEPAY:
		cmd = SP_DIO_DISPENSE_LIST;
		break;
	default:
		trace(L6, _T("  ERROR:  Unknown recycler model.  Cannot get dispense list."));
		return FALSE;
	}


	try
	{
		pString = csTemp.AllocSysString();
		rc = DirectIO(cmd, &pData, &pString);

		if(rc == 0)
		{
			csTarget = pString;
		}

		SysFreeString(pString);
	}
	catch(CMemoryException *me)
	{
		trace(L6, _T("  ERROR:  CMemoryException thrown!  Returning FALSE"));
		me->Delete();
		return FALSE;
	}

	trace(L7, _T("-CCashRecyclerWrapper::GetRawCurrencyString(%d); rc: %d"), pData, rc);
	return rc == 0 ? TRUE : FALSE;
}

long CCashRecyclerWrapper::ReadCashCountsInternal( 
   CString& sResult )
   {
   BSTR bstrCashCounts = NULL;
   BOOL bDiscrepancy = FALSE;
   sResult.Empty();
	long lResult = TOPOSCashChanger<CGenericOposIF>::ReadCashCounts( &bstrCashCounts , &bDiscrepancy );
   if ( lResult == OPOS_SUCCESS )
      sResult = CString( bstrCashCounts );
   ::SysFreeString( bstrCashCounts );
   trace(L7, _T("ReadCashCountsInternal sResult %s"), sResult);
   return lResult;
   }


CString CCashRecyclerWrapper::GetLowIndicatorList( 
   void )
   {
   CString sNotePart;
   CString sCoinResult;
   CString sNoteResult;
   long lResult = ReadCashCountsInternal( sNotePart );
   trace(L7, _T("GetLowIndicatorList sNotePart %s"), sNotePart);
   if ( lResult == OPOS_SUCCESS )
      {
      CString sCoinPart = StrToken( sNotePart, _T(";") );
      for ( int nIndex = 0; nIndex < m_aDispenseCoins.GetSize(); nIndex++ )
         {
         TClassPtr<CCashDispenseUnit> pUnit = m_aDispenseCoins.GetAt( nIndex );
         long nCount = 0;
         VERIFY( PluckSpecificTotal( sCoinPart, pUnit->m_dwUnit, &nCount ) != FALSE );
         if ( nCount == 0 ) 
            BuildCashListString( sCoinResult, 2 ); // Empty
         else if ( nCount > 10 ) 
            BuildCashListString( sCoinResult, 1 ); // Low
         else
            BuildCashListString( sCoinResult, 0 ); // Normal
         }
      for ( nIndex = 0; nIndex < m_aDispenseNotes.GetSize(); nIndex++ )
         {
         TClassPtr<CCashDispenseUnit> pUnit = m_aDispenseNotes.GetAt( nIndex );
         long nCount = 0;
         VERIFY( PluckSpecificTotal( sNotePart, pUnit->m_dwUnit, &nCount ) != FALSE );
         if ( nCount == 0 ) 
            BuildCashListString( sNoteResult, 2 ); // Empty
         else if ( nCount > 10 ) 
            BuildCashListString( sNoteResult, 1 ); // Low
         else
            BuildCashListString( sNoteResult, 0 ); // Normal
         }
      }
   return sCoinResult + _T(";") + sNoteResult;
   }


/* virtual */
long CCashRecyclerWrapper::DoOneTimeInitialization(
   void )
   {
   // Get dispense container information from the SO
   CString sCode = GetCurrencyCode();
   CString sNotePart = GetExitCashList();
   CString sCoinPart = StrToken( sNotePart, _T(";") );
   CString csDeviceName = GetDeviceName();

   // Determine the model type of this recycler.
   // dm.m_csCashRecyclerModel has not been initialized at this point.
   csDeviceName.MakeUpper();
   if(csDeviceName.Find(_CASHDISPENSER_SAFEPAY) != -1)
   {
		m_ModelID = DEVID_SAFEPAY;
   }
   else if(csDeviceName.Find(_CASHDISPENSER_GLORY) != -1)
   {
		m_ModelID = DEVID_GLORY;
   }
   else
   {
   		m_ModelID = DEVID_UNKNOWN;
		trace(L6, _T("ERROR:  This cash recycler model is not supported [%s]"), csDeviceName);
   }

   trace(L6, _T("Recycler model name: %s [%d]"), csDeviceName, m_ModelID);

   while ( sCoinPart.IsEmpty() == FALSE )
      {
      DWORD dwUnit = _ttoi( StrToken( sCoinPart, _T(",") ) );

      TClassPtr<CCashDispenseUnit> pUnit = new CCashDispenseUnit( sCode, dwUnit );
      // Ordered list from the exit cash list
      m_aDispenseCoins.Add( pUnit );
      }
   while ( sNotePart.IsEmpty() == FALSE )
      {
      DWORD dwUnit = _ttoi( StrToken( sNotePart, _T(",") ) );
      TClassPtr<CCashDispenseUnit> pUnit = new CCashDispenseUnit( sCode, dwUnit );
      // Ordered list from the exit cash list
      m_aDispenseNotes.Add( pUnit );
      }
   // Initialize denomination tables for use in BuildCoinDispenseStr()/BuildNoteDispenseStr()
   m_aCoinDenom.SetSize(6);
   m_aCoinDenom[0] = 1;
   m_aCoinDenom[1] = 5;
   m_aCoinDenom[2] = 10;
   m_aCoinDenom[3] = 50;
   m_aCoinDenom[4] = 100;
   m_aCoinDenom[5] = 500;

   m_aNoteDenom.SetSize(4);
   m_aNoteDenom[0] = 1000;
   m_aNoteDenom[1] = 2000;
   m_aNoteDenom[2] = 5000;
   m_aNoteDenom[3] = 10000;
   m_bDepositState = false;		// TAR 311332

	ResetCounts();

   return OPOS_SUCCESS;
   }

/**
 * This override handles the case of a SafePay device error when the 
 * application is first loaded.  FastLane needs the cashrecycler wrapper in 
 * order to determine the error, but CDeviceManagerEx::GetDevice() throws an 
 * exception if the device status is not DM_DA_LOADED.
 */
BOOL CCashRecyclerWrapper::IsAvailable(void)
{
	CString csDeviceName;
	
	if(m_ModelID == DEVID_UNKNOWN)
	{		
		// Either we have an unknown cash recycler OR the device is in an
		// error state and DoOneTimeInitialization has not been called yet.
		// Try to determine if this is a SafePay recycler.
		csDeviceName = GetDeviceName();		
		csDeviceName.MakeUpper();
		if(csDeviceName.Find(_CASHDISPENSER_SAFEPAY) != -1)
		{
			// This is a SafePay.
			return(m_deviceStatistics.cStatus==DM_DA_LOADED ||
				m_deviceStatistics.cStatus==DM_DA_CONFIGURED_BUT_NOT_LOADED);
		}
	}

	// Do the default action.
	return TOPOSCashChanger<CGenericOposIF>::IsAvailable();
}

 // +TAR 354760
/**
 * Certain SafePay device errors require special handling to correct
 * (ex. entering cash management, unlocking the note cassette or
 * note cover).  
 *
 * These actions require that device manager is open and FastLane is
 * operational.
 *
 * This override causes the CheckHealth() to be successful if the 
 * SafePay returns any of the special-case errors.  This allows 
 * FastLane to start completely.
 *
 * The errors will be processed later.
 */
long CCashRecyclerWrapper::CheckHealth( long lLevel )
{
	CString csDeviceName;

	// Note:  lLevel was ignored before this TAR change.  Don't know why.
	long rc = TOPOSCashChanger<CGenericOposIF>::CheckHealth(1);
	
	if(m_ModelID == DEVID_UNKNOWN)
	{		
		// Either we have an unknown cash recycler OR the device is in an
		// error state and DoOneTimeInitialization has not been called yet.
		// Try to determine if this is a SafePay recycler.
		csDeviceName = GetDeviceName();		
		csDeviceName.MakeUpper();
		if(csDeviceName.Find(_CASHDISPENSER_SAFEPAY) != -1)
		{
			// This is a SafePay.			
			if(rc == OPOS_E_EXTENDED)
			{
				switch(GetResultCodeExtended())
				{
					// All of these errors require special handling.
					// Let FastLane load and process the errors later.
					case SFPAY_ERROR_NOTE_JAM:					// 458
					case SFPAY_ERROR_CASSETTE_JAM:				// 225
					case SFPAY_ERROR_FULL:						// 261
					case SFPAY_ERROR_HOPPER_LOCKED:				// 224 TAR 353757 
					case SFPAY_ERROR_NOTE_DEPOSIT_JAM:			// 221
					case SFPAY_ERROR_NOTE_VALIDATOR_IO_ERROR:	// 227
						return OPOS_SUCCESS;
				}
			}
		}
	}

	// Do the default action.
	return rc;
}
 // -TAR 354760

/* virtual */
void CCashRecyclerWrapper::OnOposStatusEvent( 
   long  nStatus )
   {
   PostDmEventToApplication( DM_STATUS, DMCLASS_CASHRECYCLER, m_nDeviceId, nStatus );
   return;
   }


/* virtual */
void CCashRecyclerWrapper::OnOposDataEvent(long nStatus)
{
	ProcessNotes();
	SetDataEventEnabled( TRUE );
	return;
}

/*	  virtual*/
void CCashRecyclerWrapper::OnOposDirectIOEvent( long EventNumber, LONG* pData, BSTR* pString )
{
	int evtCat = DM_DIRECTIO;

	// Glory directIO events are handled in the DM_ERROR case of DMParse.
	if(m_ModelID == DEVID_GLORY)
	{
		evtCat = DM_ERROR;
	}
	PostDmEventToApplication( evtCat, DMCLASS_CASHRECYCLER, m_nDeviceId, EventNumber );
}

void CCashRecyclerWrapper::ProcessNotes(
   void )
   {
   CString sCode = GetCurrencyCode();
   CString sNotePart = GetDepositCounts();
   CString sCoinPart = StrToken( sNotePart, _T(";") );
   while ( sCoinPart.IsEmpty() == FALSE )
      {
      DWORD nUnit = 0;
      long nCount = 0;
      VERIFY( ReadCashCountFromString( sCoinPart, &nUnit, &nCount ) != FALSE );
      TClassPtr<CCashDispenseUnit> pUnit;
      CString sTemp;
      sTemp.Format( _T("%s%d"), sCode, nUnit );
      if ( m_mapDepositCoins.Lookup( sTemp, pUnit ) == FALSE )
         {
         pUnit = new CCashDispenseUnit( sCode, nUnit );
         m_mapDepositCoins.SetAt( sTemp, pUnit );
         }
      long nNewCount = pUnit->SetCurrentCount( nCount );
      CString sCoinData;
      sCoinData.Format( _T("%s%d"), sCode, nUnit );
      while ( nNewCount-- != 0 )
         PostDmEventToApplication( DMCLASS_COINACCEPTOR, m_nDeviceId, sCoinData );  
      }
   while ( sNotePart.IsEmpty() == FALSE )
      {
      DWORD nUnit = 0;
      long nCount = 0;
      VERIFY( ReadCashCountFromString( sNotePart, &nUnit, &nCount ) != FALSE );
      TClassPtr<CCashDispenseUnit> pUnit;
      CString sTemp;
      sTemp.Format( _T("%s%d"), sCode, nUnit );
      if ( m_mapDepositNotes.Lookup( sTemp, pUnit ) == FALSE )
         {
         pUnit = new CCashDispenseUnit( sCode, nUnit );
         m_mapDepositNotes.SetAt( sTemp, pUnit );
         }
      long nNewCount = pUnit->SetCurrentCount( nCount );
      CString sNoteData;
      sNoteData.Format( _T("%s%d"), sCode, nUnit );
      while ( nNewCount-- != 0 )
         PostDmEventToApplication( DMCLASS_CASHACCEPTOR, m_nDeviceId, sNoteData );  
      }
   return;
   }


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void CCashDispenseUnit::AddContainerMapString( 
   CString& sInit ) const
   {
   if ( sInit.IsEmpty() == FALSE )
      sInit += _T(",");
   CString sTemp;
   sTemp.Format( _T("%s:%d"), m_sCode, m_dwUnit );
   sInit += sTemp;
   return;
   }


/* virtual */
void CCashRecyclerWrapper::SetDeviceEnabled( 
   BOOL bEnable )
   {
   // Recycler must be kept enabled, and we want to set the Result Codes at the SO
   TOPOSCashChanger<CGenericOposIF>::SetDeviceEnabled( TRUE );
   if ( bEnable == FALSE )
      m_pParentWnd->SetTimer( m_nControlId, 1500, NULL );
   else
      m_pParentWnd->KillTimer( m_nControlId );
   return;
   }


/* virtual */
void CCashRecyclerWrapper::OnTimer( 
   UINT nIDEvent )
   {
   m_pParentWnd->KillTimer( m_nControlId );
   EndDeposit( CHAN_DEPOSIT_NOCHANGE );
   return;
   }


/**
 * Function:        SetDeviceEnabledRaw    
 * Purpose:         Provide true functionality of 
 *                  TOPOSCashChanger<CGenericOposIF>::SetDeviceEnabled()                  
 * Parameters:      bEnable - If TRUE, enable the device.
 *                            If FALSE, disable the device.
 * Returns:         true if successful.
 * Calls:           
 * Side Effects:    
 * Notes:           The Glory cash recycler implementation has overridden the
 *                  default functionality of SetDeviceEnabled (see above).
 *                  For the SafePay, the device must really be disabled when 
 *                  entering LaneClosed.  If it is not disabled, then other
 *                  SafePay diagnostic utilities cannot be used while FastLane is
 *                  running.
 */
bool CCashRecyclerWrapper::SetDeviceEnabledRaw( BOOL bEnable )
{
	if(m_bDepositState)
	{
		EndDeposit(CHAN_DEPOSIT_NOCHANGE);
	}

	TOPOSCashChanger<CGenericOposIF>::SetDeviceEnabled(bEnable);

	// +TAR 356035:  If enabling the device see if the enable was successful.
	// Send an error event if it's not.
	if(bEnable && (GetDeviceEnabled() != TRUE))
	{
		trace(L4, _T("ERROR:  Failed to enable cash recycler."));
		PostDmEventToApplication(DM_ERROR, DMCLASS_CASHRECYCLER, 
			m_nDeviceId, OPOS_E_DISABLED);
		return false;
	}
	// -TAR 356035

	return true;
}
