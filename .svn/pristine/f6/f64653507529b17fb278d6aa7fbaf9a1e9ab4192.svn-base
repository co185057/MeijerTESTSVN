#if !defined(AFX_DEVMGR_H__5E2D6E61_576B_11D4_890D_00A0C9EDD46B__INCLUDED_)
#define AFX_DEVMGR_H__5E2D6E61_576B_11D4_890D_00A0C9EDD46B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CDevMgr wrapper class
#include <TClassPtr.h>
#include "dmx\DmxOposIF.h"
//  
#include "dmx\DMInterface.h"
#include <CmDataCapture.h>
//SR672 - Enhanced device error display - Begin
#include "oposbill.h"
#include "oposcacc.h"
#include "ncrcch.h"
#include "OposPtr.h"
//SR672 - Enhanced device error display - End


#define DMCLASS_MOTION_SENSOR		(DMCLASS_MAX_CLASSES+1)
#define DMCLASS_EASDEACTIVATOR	(DMCLASS_MAX_CLASSES+2)
#define DMCLASS_CASHRECYCLER	   (DMCLASS_MAX_CLASSES+3) // TPB
#define DMCLASS_CARDDISPENSER   (DMCLASS_MAX_CLASSES+4)		//4.2 card dispenser

class CDevMgr : public CWnd  
   {
   public:
	   CLSID const& GetClsid()
	      {
		   static CLSID const clsid
			   = { 0xbc20b3e3, 0xacf1, 0x11d0, { 0xb0, 0x8e, 0x10, 0x0, 0x5a, 0x74, 0x4d, 0xc6 } };
		   return clsid;
      	}
	BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ 
//   m_pParentWnd = pParentWnd;
   return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); 
   }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ 
//   m_pParentWnd = pParentWnd;
   return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetFileDescription();
	void SetFileDescription(LPCTSTR);
	CString GetFileVersion();
	void SetFileVersion(LPCTSTR);
	CString GetLegalCopyright();
	void SetLegalCopyright(LPCTSTR);
	BOOL GetInputEventEnabled();
	void SetInputEventEnabled(BOOL);

// Operations
public:
	virtual void Open();
	virtual void Close();
	virtual void Enable(long DeviceID, long DeviceClass, BOOL fEnable);
	virtual long GetAvailableDevices(long DeviceClass);
	virtual CString GetDeviceDescription(long DeviceID, long DeviceClass);
	virtual void ClearInput(long DeviceClass);
	void MiscSetIndicator(long DeviceID, long Indicator, long State);
	void MiscGetIndicatorStatus(long DeviceID, long Indicator, long* pState);
	void EncryptorClearKey(long DeviceID, long KeyNumber);
	void EncryptorGetPinBlock(long DeviceID, long KeyNumber, LPCTSTR AccountNum);
	void EncryptorStoreKey(long DeviceID, long KeyNumber, LPCTSTR Key, long Action, long ExchangeKey);
   // Cash Changer APIs
	CString GetCashChangerLowIndicatorList(long DeviceID);
	CString GetCashChangerDispensedCashList(long DeviceID);
	void CashChangerReplenishCoins(long DeviceID, long* plData, BSTR* pbsData);
	void CashChangerGetStatusValues(long DeviceID, long* plCoinStatus, long* plBillStatus);
	void CashChangerDispense(long DeviceID, long Amount);
	void CashChangerDispense(long DeviceID, LPCTSTR CashCounts); //dp185016 support glory device
	void CashChangerGetCashCounts(long DeviceID, BSTR* pCashCounts, BOOL* pDiscrepancy);
	void CashChangerGetTamperStatus(long DeviceID, BSTR* pTamperStatus);
	CString GetCashChangerCurrencyCashList(long DeviceID);
	CString GetCashChangerCurrencyCode(long DeviceID);
	CString GetCashChangerCurrencyCodeList(long DeviceID);
	CString GetCashChangerCurrencyContainerMap(long DeviceID);
	BOOL GetCashChangerTampIndicatorEnabled(long DeviceID);
	void SetCashChangerTampIndicatorEnabled(long DeviceID, BOOL bNewValue);
	BOOL GetCashChangerCashTaken(long DeviceID);
	void SetCashChangerCashTaken(long DeviceID, BOOL bNewValue);
   // Encryptor APIs
	CString GetEncryptorEncryptedPIN(long DeviceID);
	long GetCashAcceptorAsyncResultCode(long lDeviceID);
	CString GetCashAcceptorCurrencyAcceptList(long lDeviceID);
	void SetCashAcceptorCurrencyAcceptList(long lDeviceID, LPCTSTR lpszNewValue);
	CString GetCashAcceptorCurrencyCashList(long lDeviceID);
	CString GetCashAcceptorCurrencyCode(long lDeviceID);
	void SetCashAcceptorCurrencyCode(long lDeviceID, LPCTSTR lpszNewValue);
	CString GetCashAcceptorCurrencyCodeList(long lDeviceID);
	long GetCashAcceptorDeviceStatus(long lDeviceID);
	BOOL GetCashAcceptorCapEscrow(long lDeviceID);
	BOOL GetCashAcceptorAutoDisable(long lDeviceID);
	void SetCashAcceptorAutoDisable(long lDeviceID, BOOL bNewValue);
	void CashAcceptorAccept(long lDeviceID);
	void CashAcceptorReject(long lDeviceID);
	void CashAcceptorReadBillCounts(long lDeviceID, BSTR* pCashCounts);
	void CashAcceptorResetBillCounts(long lDeviceID);
	virtual void CheckHealth(long DeviceClass, long DeviceID, long Level);
	virtual CString GetDeviceAvailability(long DeviceClass);
	BOOL GetAutoDisable(long DeviceID, long DeviceClass);
	void SetAutoDisable(long DeviceID, long DeviceClass, BOOL bNewValue);
	void SigCapBeginCapture(long DeviceID, LPCTSTR FormName);
	void SigCapEndCapture(long DeviceID);
	void SigCapDataToBitmap(long DeviceID, LPCTSTR FileName);
	void SigCapSetWindowHandle(long DeviceID, long* pHWnd);
	void SigCapDataTo5991Format(long DeviceID, BSTR* pbsData);
	long GetSigCapNotifyStyle(long DeviceID);
	void SetSigCapNotifyStyle(long DeviceID, long nNewValue);
	void CoinAcceptorAccept(long DeviceID);
	void CoinAcceptorReadCoinCounts(long DeviceID, BSTR* pCoinCounts);
	void CoinAcceptorReject(long DeviceID);
	void CoinAcceptorResetCoinCounts(long DeviceID);
	CString GetCoinAcceptorCurrencyCode(long DeviceID);
	void SetCoinAcceptorCurrencyCode(long DeviceID, LPCTSTR lpszNewValue);
	BOOL GetCoinAcceptorEnableCoins(long DeviceID);
	void SetCoinAcceptorEnableCoins(long DeviceID, BOOL bNewValue);
	long GetCoinAcceptorAsyncResultCodeExt(long DeviceID);
	BOOL GetCoinAcceptorCapFullSensor(long DeviceID);
	BOOL GetCoinAcceptorCapEscrow(long DeviceID);
	BOOL GetCoinAcceptorCapNearFullSensor(long DeviceID);
	CString GetCoinAcceptorCoinData(long DeviceID);
	long GetCoinAcceptorCoinEscrowAmount(long DeviceID);
	long GetCoinAcceptorCoinEscrowCount(long DeviceID);
	CString GetCoinAcceptorCoinList(long DeviceID);
	CString GetCoinAcceptorCurrencyCodeList(long DeviceID);
	long GetCoinAcceptorDeviceStatus(long DeviceID);
	long GetCoinAcceptorAsyncResultCode(long DeviceID);
	long GetEncryptorPINBlockFormat(long DeviceID);
	void SetEncryptorPINBlockFormat(long DeviceID, long nNewValue);
	long GetResultCodeExtended(long DeviceClass, long DeviceID);
	CString GetDeviceName(long DeviceClass, long DeviceID);
    //+SR742
    void CoinAcceptorOpenDevice(long DeviceID); 
    void CashAcceptorOpenDevice(long DeviceID); 
    void CashChangerOpenDevice(); 
    void CashChangerCloseDevice();
    //-SR742
    //+SR700
    void SetCMState(long bNewValue);
    void CashchangerSetCashCounts(long DeviceID, LPCTSTR CashCounts);
    BOOL GetCoinAcceptorEnabled(long DeviceID);
    long DirectIO(long DeviceID, long DeviceClass, long cmnd, long* pData, BSTR* pbsData);
    void CashChangerSetPurgedCounts(long DeviceID, LPCTSTR PurgeCounts);
    void CashChangerGetPurgedCounts(long DeviceID, BSTR* pPurgedCounts, BOOL* pDiscrepancy);    
    //-SR700
protected:
//   CWnd* m_pParentWnd;
};



class CDeviceSet : 
   public CArray<TClassPtr<CGenericOposIF>, TClassPtr<CGenericOposIF> >
   {
   public:
      CDeviceSet( long nDeviceClass, long nOffset );

      // Allow access to  common OPOS functionality
      CGenericOposIF* GetOposDevice( long nDeviceId ) { return GetAt( nDeviceId ); }
      void CreateDevices( CString sKey, class CDeviceManagerEx* pDMX, int nRetries, int nRetrySleep );
	  bool IsSamePrinterReceiptSlip();  //RFC 356020 // RFQ 7477
      // This code should not be necessary but is added as a workaround for the
      // 5995 cleanup problem described in Tar #196038
      ~CDeviceSet( void );
         
   private:
      const long  m_nDeviceClass;
      const long  m_nOffset;
   
   };


class CDeviceConfiguration : 
   public CArray< TClassPtr<CDeviceSet>, TClassPtr<CDeviceSet> >
   {
   public:
      CDeviceConfiguration( int nOffset = 0, int nRetries = 1, int nRetrySleep = 100 );
      void Open( LPCTSTR sConfig, class CDeviceManagerEx* pDMX );
      void Close( void );

    //+SR742
    void MSROpenDevice( LPCTSTR sConfig, class CDeviceManagerEx* pDMX ); 
    void MSRCloseDevice(void);
    //-SR742
	
      BOOL IsClassSupported( long nDeviceClass ) const;
      CGenericOposIF* GetDevice( long  nDeviceClass, long  nDeviceId ) const;
      CString GetDeviceAvailability( long nDeviceClass ) const;
      void LinkTo( const CDeviceConfiguration* pLocalCfg )
         { m_pLocalCfg = pLocalCfg; }
      void AssignPrinterDeviceId( long nDeviceClass, CPrinterWrapper* pPrinter );
      /**
       * RFC 445940.
       * Create / configure print stations.
       */
      void LoadPrinterStations(void);
   private:
      const CDeviceConfiguration*   m_pLocalCfg;
   private:          
      long GetDeviceCount( long nDeviceClass ) const;
   private:
      const long m_nOffset;
	  int   m_nRetries;
      int   m_nRetrySleep;

   };

class CRemoteDeviceConfiguration : public CDeviceConfiguration 
   {
   public:
      CRemoteDeviceConfiguration(); 
      BOOL IsDeviceRemote( long nDeviceClass, long nDeviceId ) const;
      static int GetRemoteOpenRetries();
      static int GetRemoteOpenSleep();
   };

class CDeviceManagerEx : public CDevMgr 
   {
   public:
       CDeviceManagerEx();
       virtual ~CDeviceManagerEx();

      static void ThrowDmException( long  nDeviceClass, long lResult, long nRcEx );
      static void ThrowDmException( SCODE sc );
      static void ThrowDmException( CGenericOposIF* pDevice );
      static void ThrowDmException( class CPrintStation* pDevice );
   public:
      CGenericOposIF* GetDevice( long nDeviceClass, long nDeviceId );
      CGenericOposIF* GetDeviceByCtrlId( long nCtrlId );
//      DECLARE_DYNCREATE(CDeviceManagerEx )
	   virtual void Open();
	   virtual void Close();

       /**
        * RFC 445940:  Reload specified device.
        * \param[in] nDeviceClass - Device class of the device to reload.
        *            All devices for the associated class will be reloaded.
        * \return OPOS return code.
        */
       virtual long Reload(long nDeviceClass);

       /**
        * RFC 445940:
        * \return true if old-style handling of device errors at lane startup
        *              should be used.  false if new error handling should 
        *              be used.
        * \note This mechanism is added as an escape hatch in case a 
        *       unintended problem arises with the new mechanism.
        *       This method can be removed if the new method does not 
        *       have any issues.
        */
       virtual bool UseLegacyStartupErrHandling(void);

       /**
        * RFC 445940:  
        * Signal that creation of a OPOS control has failed.  If a device
        * control cannot be created, we must reload the entire DMX module
        * (the way before RFC 445940).  
        */
       virtual void OnCreateDeviceFailure(void);

       /**
        * RFC 445940:  
        * \return true if there was a failure to create a control object for
        *         a device.  false otherwise.  
        *         A device can still be in a error state for another reason
        *         (hardware, etc.).
        */
       virtual bool IsCreateDeviceFailure(void) const;

	   virtual void Enable(long DeviceID, long DeviceClass, BOOL fEnable);
	   virtual long GetAvailableDevices(long DeviceClass);
	   virtual CString GetDeviceDescription(long DeviceID, long DeviceClass);
	   virtual void ClearInput(long DeviceClass);
	   virtual void CheckHealth(long DeviceClass, long DeviceID, long Level);
	   virtual CString GetDeviceAvailability(long DeviceClass);
   public:
      BOOL IsDeviceRemote( long nDeviceClass, long nDeviceId ) const;
      void OpenRemote( LPCTSTR sKey  );
      void CloseRemote( void );
      void ReloadMSR( void); //SR742
      // Provide low-level access to the devices
      CPrintStation* GetPrintStation( long nDeviceClass, long nDeviceId = 0 );
      class CPrinterWrapper* GetPrinter( long nDevClass, long nDeviceId = 0 );
      class CScannerWrapper* GetScanner( long nDeviceId );
      class CMICRWrapper* GetMICR( long nDeviceId );
      class CKeylockWrapper* GetKeylock( long nDeviceId );
      class CCashDrawerWrapper* GetCashDrawer( long nDeviceId );
      class CMSRWrapper* GetMSR( long nDeviceId );
      class CMotionSensorWrapper* GetMotionSensor( long nDeviceId );
      class CEASWrapper* GetEASWrapper( long nDeviceId );
	  class CCardDispenser* GetCardDispenser( long nDeviceID );
      class CCashRecyclerWrapper* GetCashRecycler( long nDeviceId );
      class CScaleWrapper* GetScaleWrapper( long nDeviceId );
      long GetMaxClasses( void ) const;
      CDeviceStatistics GetDeviceStatistics( long nDevClass, long nDeviceId = 0 );
      CWnd* GetThreadWindow( UINT nThreadId );
      BOOL OnOposErrorEvent( UINT  nCtrlId, long  nResult, long  nRcEx, long  nErrorLocus, 
         long FAR* pnErrorResponse );
      BOOL OnOposDataEvent( UINT nCtrlId, long nStatus );
      BOOL OnOposStatusUpdateEvent( UINT  nCtrlId, long  nStatus );
      BOOL OnOposOutputCompleteEvent( UINT  nCtrlId, long  nOutputId );
      BOOL OnOposDirectIOEvent( UINT    nCtrlId, long    nEventId, long*   plData, 
          BSTR*   pbstrData );
   private:
      // These device are the "local" devices.
      CDeviceConfiguration m_cfgLocal;
      // These device are the "remote" devices.
      CRemoteDeviceConfiguration m_cfgRemote;
	  // Fix TAR 322422 - Stopping Fastlane from Launchpad causes a Dr.Watson on ADK 4.2.1/ADD 1.08.02 
	  BOOL m_bShutdownInProgress;

      bool m_bCreateDeviceFailure;      // RFC 445940

   private:
      COleDispatchDriver   m_RemoteSO;
      CMap< UINT, UINT, TClassPtr<DMInterface>, TClassPtr<DMInterface> > m_mapIdToDMI;
      mutable CmDataCapture     m_cmDc;
   };

CString ReadRegString( HKEY     hKey,    LPCTSTR  pszValue );

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEVMGR_H__5E2D6E61_576B_11D4_890D_00A0C9EDD46B__INCLUDED_)
