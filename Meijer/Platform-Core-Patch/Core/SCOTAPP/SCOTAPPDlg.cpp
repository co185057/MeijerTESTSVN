//////////////////////////////////////////////////////////////////////////////////////////////////
//
// FILE:  SCOTAPPDlg.cpp
//
// TITLE:   Application Second Level Launch File.
//
// SCOTAPP stands for SCOT IBM SMKT version
//
// Note: Most of this file was generated by the MFC App Wizard
// Changes for SCOT are noted.
// This module shows all store mode screens
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <process.h>
#include "DMCashCount.h"
#include "SCOTApp.h"
#include "SCOTAPPDlg.h"
#include "Common.h"                 // MGV common headers
#include "DMProcedures.h"           // MGV DM procedures
#include "SCOTEncryptor.h"
//#include "SCOTMotionSensor.h"
#include "SMState.h"                // MGV base state
#include "MPProcedures.h"           // MGV MP Object
#include "HTProcedures.h"
#include "RAProcedures.h"           // Remote Approval Interface Object
//Begin_Service
#define SCOTAPPEVENTLOG _T("SCOTAPP")        // EventLog Source
#define SCOTAPPTRACEFILE _T("%DATA_DRIVE%\\scot\\logs\\Traces.log")    //Trace file name


DLLEXPORT HWND		hw;                  // Global
SCOTAPPErrorObject	eo(SCOTAPPEVENTLOG);  // Instance
ScotAppBusyStatus   appBusy(SCOTAPPEVENTLOG); //Instance
TraceObject			to(SCOTAPPTRACEFILE);    // Instance
MsgObject			mo(hw, &to);                   // Instance
ConfigObject		co;                      // Instance
//NN RFC 210177
CString csMachineName = co.csLocalMachineName;	
CString csFilePath = _T("%DATA_DRIVE%\\scot\\logs\\") + co.csLocalMachineName + _T(".log");	
TraceObject         misMatchTrace(csFilePath);
//RFC 210177 end
ItemObject			io;                      // Instance
CustomMessage		cm;                      // Instance - TAR #127247  
CustomMessage		CustomMessageObj;        // Instance - TAR #127247  
CSCOTTrainingMode TrainingModeObj;
CReporting			rp;  
// NewSec
DLLEXPORT SecMgrProcedures SecMgr; // global Security Manager object

DLLEXPORT CSCOTDataEntry cDataEntry;

extern DWORD dwTime;

#ifdef _BUILDLIB_
PSProceduresBase tempPS;
DLLEXPORT PSProceduresBase &ps = tempPS;
CCustomerInfoBase tempCustInfo;
DLLEXPORT CCustomerInfoBase &custInfo = tempCustInfo;
#endif

DLLEXPORT DMProcedures  dm;              // Instance
DLLEXPORT DMCashCount  dmcc;              // Instance PW500001 CashManagement Rel 4 Patch C
/******************************
CM150000:  Removed in Merged Code
DLLEXPORT CReceiptQ     rq;
DLLEXPORT CJournalQ     jq; 
******************************/
DLLEXPORT CInstoreCode	cstoreCode;
DLLEXPORT CConfigMultiLabelBarcode g_MultiLabelBarcodes;
DLLEXPORT HTProcedures ht;               // Hard totals instance
RAProcedures ra;                         // Instance of remote approval interface object

// Support for "Straight" OPOS Devices
CSCOTDevFactory			gSCOTDevFactory;

CSCOTEncryptor*			gpSCOTEncryptor = NULL;
CSCOTSigCap*			gpSCOTSigCap    = NULL;
CSCOTAuxDisp*			gpSCOTAuxDisp   = NULL;
CSCOTTakeawayBelt*      gpSCOTTakeawayBelt = NULL;

//TSProcedures  ts;                      // Instance
DLLEXPORT MPProcedures  mp;              // Instance

DLLEXPORT CWnd * pDialogWindow = NULL;   // Access to dialog

DLLEXPORT CStatic *h2X20 = NULL;         // Dialog 2x20 display area
DLLEXPORT HFILE hEPSPrintFile;			 // Global file handle for Electronic Payment SubSystem Print stuff, used for EOD


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
 
#define COMP_ID ID_MP               // main program
#define T_ID _T("Dlg")
#define ONE_SECOND 1000
// end SCOT

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
  CAboutDlg();
	
  // Dialog Data
  //{{AFX_DATA(CAboutDlg)
  enum { IDD = IDD_ABOUTBOX };
  //}}AFX_DATA
	
  // ClassWizard generated virtual function overrides
  //{{AFX_VIRTUAL(CAboutDlg)
protected:
  virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
  //}}AFX_VIRTUAL
	
  // Implementation
protected:
  //{{AFX_MSG(CAboutDlg)
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
  //{{AFX_DATA_INIT(CAboutDlg)
  //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
  CDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CAboutDlg)
  //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
//{{AFX_MSG_MAP(CAboutDlg)
// No message handlers
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSCOTAPPDlg dialog

CSCOTAPPDlg::CSCOTAPPDlg(CWnd* pParent /*=NULL*/)
: CDialog(CSCOTAPPDlg::IDD, pParent)
{
  //{{AFX_DATA_INIT(CSCOTAPPDlg)
  // NOTE: the ClassWizard will add member initialization here
  //}}AFX_DATA_INIT
  // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_bLoadPOSAssistMode = LoadPOSAssistMode();
}

void CSCOTAPPDlg::DoDataExchange(CDataExchange* pDX)
{
  CDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CSCOTAPPDlg)
  // NOTE: the ClassWizard will add DDX and DDV calls here
  //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSCOTAPPDlg, CDialog)
//{{AFX_MSG_MAP(CSCOTAPPDlg)
ON_WM_SYSCOMMAND()
ON_WM_PAINT()
ON_WM_QUERYDRAGICON()
ON_WM_TIMER()
ON_WM_SIZE()
//}}AFX_MSG_MAP
//ON_REGISTERED_MESSAGE(mo.ScotMessageID,OnUserMessage)
ON_MESSAGE(mo.ScotMessageID,OnUserMessage)
ON_MESSAGE(WMU_LOADCONTROL_CLOSE,OnUserMessage2)
ON_MESSAGE(WMU_STOP_SCOT,OnStopSCOT)
ON_MESSAGE(WMU_PUT_SCOT_IN_LC,OnPutSCOTinLC)
ON_MESSAGE(WMU_QUERY_SCOT_STATE, OnQuerySCOTState)
ON_MESSAGE(WMU_SCOT_GETDIAGFILES, OnGetDiagFiles)
ON_MESSAGE(WMU_GET_TEXT, OnGetSCOTText) //+dp185016 rfc 265463
ON_MESSAGE(WMU_STOP_SCOT_POWER, OnPowerStopSCOT) //-dp185016
END_MESSAGE_MAP()



///////////////////////////////
// CSCOTAPPDlg message handlers
BOOL CSCOTAPPDlg::OnInitDialog()
{
  //Begin_EventLog
//   eo.Initialize();
  //End_EventLog

  ScotError(INFO,SM_CAT_STARTUP_INIT, SCOTAPP_INITIALIZE);

  CDialog::OnInitDialog();
	
  // Add "About..." menu item to system menu.
	
  // IDM_ABOUTBOX must be in the system command range.
  ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
  ASSERT(IDM_ABOUTBOX < 0xF000);
	
  CMenu* pSysMenu = GetSystemMenu(false);
  if (pSysMenu != NULL)
  {
    CString strAboutMenu;
    strAboutMenu.LoadString(IDS_ABOUTBOX);
    if (!strAboutMenu.IsEmpty())
    {
      pSysMenu->AppendMenu(MF_SEPARATOR);
      pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
    }
  }
	
  pDialogWindow = this;
	
#ifdef _DEBUG
  SetWindowText(_T("SCOTAPP Debug Dialog"));
  CString csThreadInfo;
  csThreadInfo.Format(_T("main Thread ID: %d (0x%x)"), GetCurrentThreadId(), GetCurrentThreadId());
  GetDlgItem(IDC_STATIC_TID)->SetWindowText(csThreadInfo);
#else
  SetWindowText(_T("SCOTAPP Release Dialog"));
#endif
  SetWindowText(_T("SCOTInputWindow")); // Changed for the load controller program.
  long rc = SetWindowPos(&CWnd::wndBottom, 0, 0, 0,  0, SWP_NOMOVE | SWP_NOSIZE );	
  // Set the icon for this dialog The framework does this automatically
  // when the application's main window is not a dialog
  SetIcon(m_hIcon, true);           // Set big icon
  SetIcon(m_hIcon, false);          // Set small icon
	
  // TODO: Add extra initialization here
	
  // Added for SCOT
  h2X20 = (CStatic *)GetDlgItem(IDC_STATIC2X20);
  if (h2X20) h2X20->SetWindowText(_T("Initializing..."));
  // post ourselves a message to initialize ourselves
  // from the OnUserMessage after everything else is
  // up and running
  PostMessage(mo.ScotMessageID,NULL);   // this is the only NULL message
  // end SCOT

  // TAR 200294 NN 041602 - We do not want DM events to reset the timer.  So we are letting
  //the timer run all the time.  
  // For this TAR changes have been made to SMStateBase.cpp, SMAttractBase.cpp, SMTakeReceiptBase.cpp, and SCOTAPPDlg.cpp
  SetTimer(SCOTAPP_NORMAL,ONE_SECOND,NULL);	// set a timer	
	
  return true;                      // return true  unless you set the focus to a control
}

//////////////////////////////////////////////////////
void CSCOTAPPDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
  if ((nID & 0xFFF0) == IDM_ABOUTBOX)
  {
    CAboutDlg dlgAbout;
    dlgAbout.DoModal();
  }
  else
  {
    CDialog::OnSysCommand(nID, lParam);
  }
}

//////////////////////////
// If you add a minimize button to your dialog, you will need the code below
// to draw the icon For MFC applications using the document/view model,
// this is automatically done for you by the framework.
void CSCOTAPPDlg::OnPaint()
{
  if (IsIconic())
  {
    CPaintDC dc(this);              // device context for painting
		
    SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);
		
    // Center icon in client rectangle
    int cxIcon = GetSystemMetrics(SM_CXICON);
    int cyIcon = GetSystemMetrics(SM_CYICON);
    CRect rect;
    GetClientRect(&rect);
    int x = (rect.Width() - cxIcon + 1) / 2;
    int y = (rect.Height() - cyIcon + 1) / 2;
		
    // Draw the icon
    dc.DrawIcon(x, y, m_hIcon);
  }
  else
  {
    CDialog::OnPaint();
  }
}

/////////////////////////////////////
// The system calls this to obtain the cursor to display while the user drags
// the minimized window.
HCURSOR CSCOTAPPDlg::OnQueryDragIcon()
{
  return (HCURSOR) m_hIcon;
}

/////////////////////////////////////////////////////////////
// All remaining code was added for SCOT

void CSCOTAPPDlg::OnCancel()
{
  ScotError(INFO,SM_CAT_CONFIGURATION, SCOTAPP_STOP_REQUEST_FROM_DIALOG);
  mo.PostGP(GP_STOP);
}

////////////////////////////////////
static long CheckReturnCode(long rc)
{
  if (rc==-1)
  {
    // shut SCOT down now
    mp.UnInitialize();
    to.CloseTraceFile();
    //Begin_EventLog
		//eo.Close();
    //End_EventLog
    // then do normal shut down
    return rc;
  }
	
  if (rc==-2)
  {
    // shut SCOT down now
    mp.UnInitialize();
		
    // When the restart value is 0, we will RE-start the app for the first
    // time (or second start total.)  When the value is 1, we will restart
    // for the second time (third and final time total).
    long arcRC = 0;
    int  count = 0;
    count = AppRestartCount::getCount(arcRC);

		trace(L4,_T("Restart count=%d, arcRC=%d"),count,arcRC);
		
    if ( arcRC == ERROR_SUCCESS && count <= 1 )
    {
      // start a new SCOT program
      _TCHAR szExeName[_MAX_PATH],*szN;
      // try to get the current EXE date, time and size
      if (SearchPath(NULL,AfxGetApp()->m_pszExeName,_T(".EXE"),_MAX_PATH,szExeName,&szN)>0)
      {
				trace(L4,_T("Restart exe = %s"),szExeName);
        // Bump the restart count.  If that's successful, restart.
        // Otherwise, we can't keep track, so don't try restarts.
        if (AppRestartCount::increment() == ERROR_SUCCESS)
        {
          LPCTSTR szAppName = AfxGetAppName();
					trace(L4,_T("Restart app = %s"),szAppName);
          //Begin_EventLog
			    //eo.Close();
          //End_EventLog
			    to.CloseTraceFile();
					Sleep(3000);					// let NT close all files and DM unload devices
          _texecl(szExeName,szAppName,NULL);
        }
      }
    }

    // then do normal shut down for this program
		trace(L4,_T("Normal Shutdown"));
    //Begin_EventLog
		//eo.Close();
    //End_EventLog
    to.CloseTraceFile();
    return rc;
  }
	
  return 0;
}

//////////////////////////////////////////////////
// This will be worked when the load controller program sends their
// user message plus one oh one code.
LONG CSCOTAPPDlg::OnUserMessage2(UINT u, LONG lMsg)
{
  ScotError(INFO,SM_CAT_CONFIGURATION, SCOTAPP_STOP_REQUEST_FROM_LOADCONTROLLER);
  mo.PostGP(GP_STOP);
  return 0;
}

/////////////////////////////////////////////////
LONG CSCOTAPPDlg::OnUserMessage(UINT u, LONG lMsg)
{
  static int nTimer = 0;					  // initially no timer
  long rc = 0;

  int nMsgSource = -1;
  if (lMsg)
  {
	  	MessageElement *Me;
		Me = (MessageElement *)lMsg;
		nMsgSource = Me->id;		
  }
  trace(L7, _T("+OnUserMessage: u=%d, lMsg=%d, nMsgSource=%d, nTimer=%d"), u, lMsg, nMsgSource, nTimer);
	
  // kill periodic timer
  //TAR 200294 NN 041602 
  // Slightly altered with help of Tom B.
  //Get rid of the KillTimer() and let the timer run all the time so it is not interrupted by DM events
  //if (nTimer) 
  //KillTimer(nTimer);							  
	
  // the lMsg will be NULL if this is from the OnInitDialog
  // so we know to do a full initialization.
  // otherwise lMsg will point to a MessageElement with
  // data from TB, Ps, DM or SA
  try
  {
    if (!lMsg)                      // message from OnInitDialog()
    {
      // a message without a lMsg has arrived. it is probably our
      // message from OnInitDialog() but it may not be, avoid
      // running the mp.Init more than once
      if (!hw)
      {
        hw = m_hWnd;                // save global hw
        mo.SetWindowHandle(hw);
        rc = mp.Initialize();       // start it all up
      }
      // ignore any further events with lMsg = 0
    }
    else                            // message from PostXX() TS, DM, PS or SA
    {
		if (dm.fStartUpDevFactoryLoading) {gpSCOTAuxDisp = NULL;}	// if the Aux display is not set to null, it tries to initialize it and fails TAR#164389 LPM022601
		MessageElement *Me;
		Me = (MessageElement *)lMsg;
				
		if(    ( ID_PS == Me->id )
		    && (    ( PS_REMOTE_DISCONNECTED != Me->psInfo.nEvt )
		        && ( PS_CONNECTREMOTE != Me->psInfo.nEvt )
		        && ( PS_SWITCHCONTEXT != Me->psInfo.nEvt ) 
                && ( PS_SWITCHCONTEXTOTHER != Me->psInfo.nEvt) )  )
		{
			//Hack fix for exiting POS assist mode
			if( m_bLoadPOSAssistMode && ps.GetCurrentContext() == _T("SmAssistMode") && PS_BUTTON2 == Me->psInfo.nEvt )
			{
				trace( L2, _T("OnUserMessage: PS processing Return to Shopping Mode from Assist Mode.") );
				rc = mp.Process( Me );

				COleVariant v;
				if( PSX_SUCCESS == ps.GetPSXObject()->GetControlProperty( UI::CONTROLDISPLAY, UI::PROPERTYHWND, v ) )
				{
					::ShowWindow( (HWND)v.lVal, SW_RESTORE );
				}
			}
			else
			{
				// Only accept events that come from the current context //
				CString strEventContext = Me->psInfo.pszContext;
				//delete [] Me->psInfo.pszContext; // removed in TAR 330666, we'll delete it later since mp.Process(Me) might be using this information
				if( strEventContext.GetLength() == 0 || strEventContext == ps.GetContextWithKeyPressed() )	//SSCOB-102
    			{
    				trace( L2, _T("OnUserMessage: PS processing DisplayEngine event.") );
    				rc = mp.Process( Me );
    			}
   				else
   				{
					//Tar 256692
					if (ps.RemoteMode() && mp.sCurr->assistMode())	//SSCOB-102
					{
						trace( L2, _T("OnUserMessage: Need to process this event even the current context not same as the context in PSX message.") );
    					rc = mp.Process( Me );
					}
					else
						trace( L2, _T("OnUserMessage: DisplayEngine event not processed. DisplayEngine event originating context = %s, current context: %s"), strEventContext, ps.GetContextWithKeyPressed() );
   				}
				
			}
        }
        else
        {
			rc = mp.Process( Me );
        }

		// mm185096 +TAR 330666
		if( ID_PS == Me->id )
		{
			try
			{
				if(Me->psInfo.pszContext!=NULL)	delete [] Me->psInfo.pszContext;
			}
			catch(...)
			{
				trace( L2, _T("OnUserMessage: delete Me->psInfo.pszContext failed." ));
			}
		}
		// -TAR 330666

		if (Me->id == ID_TRANSBROKER)
		{
			TBRC nTBRetCode = -9999;
			try
			{
				nTBRetCode = tb.ReleaseMessage(Me);
			}
			catch (CException *e)
			{
				_TCHAR szError[255] = {NULL};
				e->GetErrorMessage( szError, 255 );
				ScotError(RETURN,SM_CAT_INTERNAL_ERROR, SCOTAPP_GOT_TBEXCEPTION, _T("%s|%s"), _T("TBReleaseMessage()"), szError);
			    //	e->Delete();  You don't delete the exception if you're going to throw it again..
				throw;  //TAR205142
			}
			catch (...)
			{
				ScotError(RETURN,SM_CAT_INTERNAL_ERROR, SCOTAPP_GOT_TBEXCEPTION, _T("%s|%s"),_T("TBReleaseMessage()"), _T("Unknown exception"));
				throw;  //TAR205142 
			}
			trace(L7, _T("TBReleaseMessage() returned %d"), nTBRetCode);
		}
		else
		//+TAR205142  removed the try/catch block here because it makes no sense if we don't
		//care that Me gets deleted or not.
		{			
			delete Me;				
		}
		//-TAR205142
    }
  }
  catch(CException *e)
  {
    _TCHAR szText[100];
    e->GetErrorMessage(szText,100);
    ScotError(FATAL,SM_CAT_STOP_ABORT, SCOTAPP_RESTART2,_T("%s"),szText);

    throw;  //TAR205142  Need to make sure we get all the logs for this before we restart..
	        //and we need a Dr. Watson..If it's fatal enought to restart the application,
            //it's fatal enought to warrant Dr. W. and logs, etc..

    //rc = mp.Process(NULL);  TAR205142	Never reaches this anymore...  // a NULL message pointer means RESTART to mp...
  }

  if (CheckReturnCode(rc)) 
  {
	  CDialog::OnCancel();
  }

  // set a timer for periodic timeouts

  // TAR 200294 CMal and NN 041602.  
  // We decided to run the timer all the time.  SetTimer() has been moved to OnInitDialog() 
  
  //nTimer = SetTimer(1,ONE_SECOND,NULL);	

  //TAR 200294 end

  static bool bFirstTime = true;
  if (bFirstTime)
  {
	SetTimer(MEM_USAGE, (co.nTracingPSAPIInterval * 1000) /* every 15 minutes (by default) */, NULL);
    bFirstTime = false;
  }
  trace(L7, _T("-OnUserMessage: u=%d, lMsg=%d, nMsgSource=%d, nTimer=%d"), u, lMsg, nMsgSource, nTimer);
  if (to.nCurrentLevel <= 6)
  {
	trace(L6, _T("returning from OnUserMessage: u=%d, lMsg=%d, nMsgSource=%d, nTimer=%d"), u, lMsg, nMsgSource, nTimer);
  }
	
  return 0;
}

//////////////////////////////
void CSCOTAPPDlg::OnTimer(UINT nTimer)
{
  static bool fInUse = false;
  static bool fEmTs = false;
  long rc = 0;

  // CHu/CMal111301 - never using fEmTs & say it's a heartbeat
  //trace(L7, "Heartbeat - CSCOTAPPDlg::OnTimer(%d), fInUse=%d, fEmTs=%d", nTimer,fInUse,fEmTs );
  trace(L7, _T("Heartbeat - CSCOTAPPDlg::OnTimer(%d), fInUse=%d"), nTimer,fInUse);

  if (nTimer == 1) // App's normal timer
  {
	// CHu/CMal111301 - TAR 187425
	// Add 1 code line here, but at MOST leave this flag
	// as true for 1 attempt.  This allows the later code
	// to process, which indirectly controls calling the
	// ::OnTimedOut code in TakeReceipt/TakeChange.
    if (fInUse == true)
	{
        trace(L6, _T("CSCOTAPPDlg::OnTimer(%d), fInUse=%d possible reentry issue on next heartbeat"), nTimer,fInUse);
		fInUse = false;		  // CHu/CMal111301
		return;               // no dup entry
	}
    fInUse = true;
	// CHu/CMal111301 - TAR 187425 end
	  
    // a timeout has occurred,
    rc = mp.IdleTimer(ONE_SECOND);    // timeout
    if (CheckReturnCode(rc)) CDialog::OnCancel();
    fInUse = false;
  }
  else if (nTimer == 2) // App's mem usage trace timer
  {
    traceMem(L6);
  }
}

//////////////////////////////
void CSCOTAPPDlg::OnSize(UINT nType, int cx, int cy)
{
  // trace(L8, "CSCOTAPPDlg::OnSize()");
  // TAR 154963 - CDialog::OnSize(nType, cx, cy);
}

//////////////////////////////
LONG CSCOTAPPDlg::OnPutSCOTinLC(UINT u, LONG lMsg)
{
	mo.PostGP(GP_PUTSCOTINLC);
	return 0;
}

/////////////////////////////
LONG CSCOTAPPDlg::OnStopSCOT(UINT u, LONG lMsg)
{
	mo.PostGP(GP_STOPSCOT);
	return 0;
}

/////////////////////////////
LONG CSCOTAPPDlg::OnQuerySCOTState(UINT u, LONG lMsg)
{
	mo.PostGP(GP_QUERYSCOTSTATE);
	return 0;
}

// RFC 265463 start
/////////////////////////////
LONG CSCOTAPPDlg::OnGetSCOTText(UINT u, LONG lMsg)
{
	mo.PostGPwithParams(GP_GETTEXT, u, lMsg);
	return 0;
}
/////////////////////////////
LONG CSCOTAPPDlg::OnPowerStopSCOT(UINT u, LONG lMsg)
{
	mo.PostGP(GP_POWERSTOPSCOT);
	return 0;
}
// RFC 265463 end

/////////////////////////////
LONG CSCOTAPPDlg::OnGetDiagFiles(UINT u, LONG lMsg)
{
    trace(L0, _T("Getting all trace files flushed out..."));
    to.FlushAllObjects();
    // the below trace line may stay in the 'wait and flush' list
    trace(L0, _T("Finished flushing all trace files"));
	return 0;
}
CWnd* CSCOTAPPDlg::FindTaskWindow(CString csWindowName, bool bSearchFromEnd,
								  DWORD dwProcessId,    bool bUsePid)
{
  CWnd* pRetWnd = NULL;
  bool bFound = false;
  CString csWindowText;
  DWORD pid;

  CWnd* pWnd = AfxGetMainWnd()->GetWindow(GW_HWNDFIRST);

  while (pWnd && !bFound)
  {
    pWnd->GetWindowText(csWindowText);
    if (((!bSearchFromEnd) && (_tcsnicmp(csWindowText, csWindowName, _tcsclen(csWindowName)) == 0)) ||
        ((bSearchFromEnd) && (csWindowText.Right(_tcsclen(csWindowName)).CompareNoCase(csWindowName) == 0)))
    {
      if (bUsePid)
      {
        GetWindowThreadProcessId(pWnd->GetSafeHwnd(), &pid);
        if ((pid == dwProcessId))
        {
          pRetWnd = pWnd;
          bFound = true;
        }
      }
      else
      {
        pRetWnd = pWnd;
        bFound = true;
      }
    }

    if (!bFound)
    {
	    pWnd = pWnd->GetWindow(GW_HWNDNEXT);
    }
  }

  return pRetWnd;
}

// A little class to count the number of times we re-enter a secion of code.
// Declare an instance of this at the appropriate scope.  If GetValue() ever 
// equals something greater than one, the code has been re-entered.
class CInterlockedCounter
   {
   public:
      CInterlockedCounter()
         {
         m_lLastCounter = InterlockedIncrement(&m_lCounter);
         }
      ~CInterlockedCounter()
         {
         InterlockedDecrement(&m_lCounter);
         }
      long GetValue() 
         {
         return m_lLastCounter;
         }
   private:
      long m_lLastCounter;
      static long m_lCounter;
   };

long CInterlockedCounter::m_lCounter = 0L;

/*
// Little class used to enqueue posted window messages so we can re-post 
// them at another time.  Provide X-XRef and =XRef for easy use in a list.
class CDeferredMessage
   {
   public:
      CDeferredMessage(UINT m = 0, WPARAM wp = 0, LPARAM lp = 0) : 
         message(m), wParam(wp), lParam(lp){}
      CDeferredMessage(const CDeferredMessage& ref)
         {message=ref.message;wParam=ref.wParam;lParam=ref.lParam;}
      ~CDeferredMessage(){}
      CDeferredMessage& operator =(const CDeferredMessage& ref)
         {message=ref.message;wParam=ref.wParam;lParam=ref.lParam;return *this;}
      UINT message;
      WPARAM wParam;
      LPARAM lParam;
   };

// Little list of Window messages we have deferred.  When we return from
// processing a message, we check this list to see if any came in while
// we were busy.
static CList<CDeferredMessage, CDeferredMessage&> s_qDeferredMessages;

*/

// We implement WindowProc() to protect ourselves from re-entry into the 
// crux of the SCOTApp code...
LRESULT CSCOTAPPDlg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
       
   // We only care about user message and timer here -- everything else should be re-entrant
   // because Windows will handle them.
	if (((message >= WM_USER) && (message <= 0x7FFF)) || (message == WM_TIMER)) //RFC263887
    {
      LRESULT r = 0;
      CInterlockedCounter ilc;

      // Assert that we have not re-entered the main window's message handler
      // while handling a SCOT message, since we don't (like to) handle re-entry.
      // Actually we handle it gracefully -- but we shouldn't have to.  If you hit
      // this assertion, it's because somebody did something to cause messages
      // to get pumped while we were already handling a message.  (Bogus COM Object?)
  //    ASSERT(ilc.GetValue() == 1);
      if (ilc.GetValue() != 1)
         {
         if (ilc.GetValue() > 1)
            {
            trace(L0, _T("CSCOTAPPDlg::WindowProc - WindowProc was re-entered handling a %s message (message=%08.8x, wParam=%08.8x, lParam=%08.8x) - (entry counter is %d, it should be 1.)"), 
               (WM_TIMER == message) ? _T("WM_TIMER") : _T("SCOT"),  message, wParam, lParam, ilc.GetValue());
            if (!InSendMessage())
               {
               // If we are not in SendMessage() it should be safe to repost this messaged to the queue.
               trace(L0, _T("CSCOTAPPDlg::WindowProc - The erroneously dequeued message was deferred for later posting..."), lParam);
               CDeferredMessage Msg(message, wParam, lParam);
               // Add this window message to the deferred queue, but don't process it now.
               s_qDeferredMessages.AddTail(Msg);
               }
            else
               {
               // We are in SendMessage() -- fail the call -- we can't run on this thread!
               trace(L0, _T("CSCOTAPPDlg::WindowProc - This message was SENT from another thread.  Calling ReplyMessage() with -1 value..."), lParam);
               ReplyMessage(-1);
               }
            }
         else
            // I can't imagine how this would ever happen -- sun spots? aliens? dark matter?.
            trace(L0, _T("CSCOTAPPDlg::WindowProc - WindowProc entry counter went below 1! - (entry counter is %d, it should always be 1.)"), ilc.GetValue());
         }
      else
         {
         r = CDialog::WindowProc(message, wParam, lParam);









         }

      return r;

      }
   return CDialog::WindowProc(message, wParam, lParam);
   }

BOOL CSCOTAPPDlg::LoadPOSAssistMode()
{
	_TCHAR szLoadPOS[4];       //Default setting to No 
	DWORD  dwDataSize = sizeof(szLoadPOS); 
	LONG     lRC;
	HKEY     hKey;
	CString csRegKeyName = "LoadPOSAssistMode";
	lRC = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\NCR\\SCOT\\CurrentVersion\\SCOTAPP\\POSAssistMode"),
				 0, KEY_QUERY_VALUE, &hKey);


	lRC = RegQueryValueEx(hKey, csRegKeyName, NULL, NULL,
			  (LPBYTE)szLoadPOS, &dwDataSize);

	::RegCloseKey(hKey);
	
	if (lRC == ERROR_SUCCESS)
	{
		if( !_tcsicmp(szLoadPOS, _T("Yes")))
		{
			return true;
		}
	}
	return false;
}


//RFC263887+
/*
BOOL CSCOTAPPDlg::PumpMessage()
{

	MSG message;


	while (s_qDeferredMessages.GetCount())
	{
		memset((char *)&message, 0, sizeof(MSG)); //start with a clean structure
        CDeferredMessage Msg = s_qDeferredMessages.RemoveHead();
        trace(L0, _T("CSCOTAPPDlg::Run - pull message from deferred list: (message=%08.8x, wParam=%08.8x, lParam=%08.8x)"), Msg.message, Msg.wParam, Msg.lParam);
  	    message.hwnd = NULL;
		message.lParam = Msg.lParam;
		message.wParam = Msg.wParam;
		message.message = Msg.message;

		::TranslateMessage(&message);
		::DispatchMessage(&message);
	}
         
    return AfxGetThread()->PumpMessage();
	
}
//RFC263887-
*/

