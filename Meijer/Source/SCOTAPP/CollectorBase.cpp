///////////////////////////////////////////////////////////////////////////////////////////
//
//
// TITLE:   CollectorBase.CPP
//          Exposes an API that allows FastLane application to enter data into the 
//          reporting subsystem  It writes the data to a report file and creates, 
//          creating a new file for every transaction.  The format of the report 
//          filename is rpt_LaneNum_mmddyyyyHHMMSS.dat.
//
// AUTHOR:  Tara Duncan
// Return Value- - The status of the operation is returned.  
//           RPT_OK (0) - indicates a successful read of the transaction data file.  
//           RPTERROR_CANTCREATE - Unable to create an instance of the XML DOM object,
//               shouldn't happen under normal circumstances
//           RPTERROR_CANTLOAD - Unable to load the XML file.  Most likely cause is a 
//               corrupt XML file.
//           RPT_INVALID_FILE - Invalid file, did not contain a transaction start node
//               containing a time and station id
//           RPTERROR_COMEXCEPTION - The DOM calls returned a com exception.
//           RPTERR_EXCEPTION - Any other exceptions generated by the open
// 
/////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "CollectorBase.h"          // Track events 
#include "ScotappMsg.h"
#include "FLReportingErrors.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



#define COMP_ID ID_RP               // Base state component
#define T_ID _T("CCollector")
#define REPORTDIRECTORY _T("%DATA_DRIVE%\\scot\\report\\")  
#define REPORTPREFIX _T("rpt_")
#define REPORTENDING _T(".xml")

IMPLEMENT_DYNCREATE(CCollectorBase, CObject)// MFC Runtime class/object information
// Constructor
//////////////////////////////////////////////////////////////////////////////////
CCollectorBase::CCollectorBase()
: m_bTransactionCompleted(false),
  m_bCoInitialized(false),
  m_EventSource(NULL)
{
#ifndef NO_LOGGING
    m_EventSource = RegisterEventSource(NULL, _T("SCOTAPP"));
#endif
}
///////////////////////////////////////////////////////////////////////////////////
// Destructor
///////////////////////////////////////////////////////////////////////////////////
CCollectorBase::~CCollectorBase()
{
#ifndef NO_LOGGING
    if (NULL != m_EventSource)
    {
        DeregisterEventSource(m_EventSource);
    }
#endif
}
///////////////////////////////////////////////////////////////////////////////
// Function:    LogError                                   
// Class:       CCollectorBase                                              
// Description: Log Errors to Event Log  
// Parameters:  eventID:        
//              functionName
//              errorCode
//              errorCode2
//              Description
// Returns:     void                                         
///////////////////////////////////////////////////////////////////////////////////
void CCollectorBase::LogError(DWORD eventID, 
                                     _bstr_t &functionName, 
                                     WORD eventType, 
                                     long errorCode,
                                     long errorCode2,
                                     BSTR Description)
{
    WORD     stringCount;
    LPCTSTR  errorStringPtr[5];
    _TCHAR   errorCodeString[20];
    _TCHAR   errorCodeString1[20];
    _bstr_t  bDescription;

    #ifndef NO_LOGGING
        if (NULL != m_EventSource)
        {
            if (-1 == errorCode)
            {
                stringCount = 1;
            }
            else if (-1 == errorCode2)
            {
                stringCount = 2;
            }
            else
            {
                stringCount = 4;
            }
            errorStringPtr[0] = functionName;
            _stprintf(errorCodeString, _T("%d"), errorCode);
            errorStringPtr[1] = errorCodeString;

            _stprintf(errorCodeString1, _T("%d"), errorCode2);
            errorStringPtr[2] = errorCodeString1;
            if (-1 != errorCode2)
            {
                if (NULL == Description)
                {
                    bDescription = _T("");
                }
                else
                {
                    bDescription = Description;
                }
                errorStringPtr[3] = (_TCHAR *)bDescription;
            }


            ReportEvent(m_EventSource,          // handle to event log
                        EVENTLOG_ERROR_TYPE,    // event type 
                        SM_CAT_INTERNAL_ERROR,  // event category
                        eventID,                // event identifier
                        NULL,                   // user security identifier
                        stringCount,            // Number of strings to merge
                        0,                      // size of binary data
                        errorStringPtr,         // array of strings to merge
                        NULL);                  // binary data buffer
        }
    #endif
}
///////////////////////////////////////////////////////////////////////////////
// Function:    LogComError                                      
// Class:       CCollectorBase                                              
// Description: Log Com Errors to Event Log
// Parameters:  functionName
// Returns:     void                                         
///////////////////////////////////////////////////////////////////////////////////
void CCollectorBase::LogComError(_com_error &e, 
                                 _bstr_t &functionName)
{

    LPCTSTR  errorStringPtr[5];
    _TCHAR   errorCodeString[40];
    _bstr_t bstrSource(e.Source());
    _bstr_t bstrDescription(e.Description());
	CString csFunctionName = (const _TCHAR *) functionName; //436756


    #ifndef NO_DATACAP
    trace(L4,
        (_bstr_t)_T("%s> E_FAIL COM Exception Caught"), csFunctionName );  //436756
    trace(L4, 
        (_bstr_t)_T("Source %s, Desc: %s, Error %08lX"), 
        (bstrSource.length() > 0) ? (LPCTSTR)bstrSource : _T("null"),
        (bstrDescription.length() > 0) ? (LPCTSTR)bstrDescription : _T("null"),
        e.Error());
    trace( L4, 
        (_bstr_t)_T("Message %s"), e.ErrorMessage());

    #endif

    #ifndef NO_LOGGING
        if (NULL != m_EventSource)
        {
            errorStringPtr[0] = functionName;
            errorStringPtr[1] = (bstrSource.length() > 0) ? (LPCTSTR)bstrSource : _T("null");
            errorStringPtr[2] = (bstrDescription.length() > 0) ? (LPCTSTR)bstrDescription : _T("null");
            _stprintf(errorCodeString, _T("%08lX"), e.Error());
            errorStringPtr[3] = errorCodeString;
            errorStringPtr[4] = e.ErrorMessage();

            ReportEvent(m_EventSource,          // handle to event log
                        EVENTLOG_ERROR_TYPE,    // event type 
                        SM_CAT_INTERNAL_ERROR,  // event category
                        FLR_COM_ERROR,          // event identifier
                        NULL,                   // user security identifier
                        5,                      // Number of strings to merge
                        0,                      // size of binary data
                        errorStringPtr,         // array of strings to merge
                        NULL);                  // binary data buffer
        }
    #endif

    return;            
}
///////////////////////////////////////////////////////////////////////////////
// Function:    LogOLEError                                       
// Class:       CCollectorBase                                              
// Description: Log OLE Errors to the Event Log
// Parameters:  functionName
// Returns:     void                                         
///////////////////////////////////////////////////////////////////////////////////
void CCollectorBase::LogOLEError(COleDispatchException *e, 
                                    _bstr_t &functionName)
{

    LPCTSTR  errorStringPtr[5];
    _TCHAR   errorCodeString[40];
    CString  csFunctionName = (const _TCHAR *) functionName;  //436756



    #ifndef NO_DATACAP
    trace( L4,
        _T("%s> E_FAIL OLEDispatch Exception Caught"), csFunctionName ); //436756
    trace( L4, 
        _T("Source %s, Desc: %s, Error %08lX"), 
        e->m_strSource, e->m_strDescription, e->m_wCode);

    #endif

    #ifndef NO_LOGGING
        if (NULL != m_EventSource)
        {
            errorStringPtr[0] = functionName;
            errorStringPtr[1] = (LPCTSTR)e->m_strSource;
            errorStringPtr[2] = (LPCTSTR)e->m_strDescription;
            _stprintf(errorCodeString, _T("%08lX"), e->m_wCode);
            errorStringPtr[3] = errorCodeString;

            ReportEvent(m_EventSource,          // handle to event log
                        EVENTLOG_ERROR_TYPE,    // event type 
                        SM_CAT_INTERNAL_ERROR,  // event category
                        FLR_OLE_ERROR,          // event identifier
                        NULL,                   // user security identifier
                        4,                      // Number of strings to merge
                        0,                      // size of binary data
                        errorStringPtr,         // array of strings to merge
                        NULL);                  // binary data buffer
        }
    #endif

    return;            
}
///////////////////////////////////////////////////////////////////////////////
// Function:    CreateDOM                                       
// Class:       CCollectorBase                                              
// Description: This method will creates a new DOM object for new transaction.
//              The rootnode is also being created and appended <TransactionData /> 
// Parameters:  NONE
// Returns:     long                                         
///////////////////////////////////////////////////////////////////////////////////
long CCollectorBase::CreateDOM()
{
    trace(L7, _T("+CCollectorBase::CreateDOM"));
    HRESULT hr ;
    _bstr_t bstrRootNode;
    VARIANT_BOOL bResult;

        try
        {
             #ifndef NO_DATACAP
            // Trace
            trace(L7, _T("CCollectorBase::CreateDOM <") );
            #endif
     
            
            // Explicitly delete the document if open
            m_pNewTransacationDOM = NULL;

            hr = m_pNewTransacationDOM.CreateInstance(__uuidof(MSXML2::DOMDocument60));
            //Make sure that the DOM document object was successfully created
            if (FAILED(hr))
            {
                    #ifndef NO_DATACAP
                    trace( L4,
                    _T( "-CCollectorBase::CreateDOM> HRESULT: %d, RPTERROR_CANTCREATE"), hr );
                    #endif
                    return RPTERROR_CANTCREATE;
            }

            // Create the root element (i.e., the documentElement).
            bstrRootNode = _T("<TransactionData />");
            bResult = m_pNewTransacationDOM->loadXML(bstrRootNode);
            if (bResult != VARIANT_TRUE)
            {
            #ifndef NO_DATACAP
                    trace( L4, 
                    _T( "CCollectorBase::CreateDOM::AddRootNode> HRESULT: %d, E_FAIL"), hr );
            #endif

            #ifndef NO_LOGGING
                    LogError(FLR_LOAD_XML_FAILURE, (_bstr_t)_T("-CCollectorBase::CreateDOM"), EVENTLOG_ERROR_TYPE);
            #endif
            return RPTERROR_CANTCREATE;
            }
        #ifndef NO_DATACAP
                trace( L7,  
                _T("-CCollectorBase::CreateDOM> S_OK") );
        #endif
        return RPT_OK;//Created
        }


         catch (_com_error e)
         {

            #ifndef NO_LOGGING
            _bstr_t errString;
            LogComError(e,  (_bstr_t)_T("-CCollectorBase::CreateDOM"));
            #endif
            return RPTERROR_COMEXCEPTION;
         }

    //Catch control-specific exceptions.
    catch (COleDispatchException * e) 
        {   
            #ifndef NO_LOGGING
            _bstr_t errString;
             LogOLEError(e,  (_bstr_t)_T("-CCollectorBase::CreateDOM"));
            #endif
			e->Delete(); //TAR247967

            return RPTERROR_COMEXCEPTION;
        }
        catch (...)
        {
    
        #ifndef NO_DATACAP
                trace( L4,
                 _T("CCollectorBase::CreateDOM> E_FAIL") );
        #endif

        #ifndef NO_LOGGING
                LogError(FLR_XML_FAILURE,  (_bstr_t)_T("CCollectorBase::CreateDOM"), EVENTLOG_ERROR_TYPE);
        #endif
        trace(L4, _T("-CCollectorBase::CreateDOM"));
        return RPTERR_EXCEPTION;                   
        } 
}
///////////////////////////////////////////////////////////////////////////////
// Function:    WriteReportData                                       
// Class:       CCollectorBase                                              
// Description: WriteReportData - is a public method that accepts data in the 
//              form of string from the FastLane application. The format of 
//              the string is an XML string.  It is a single line of the file
//              described below in the Transaction Data File section.
// Parameters:  bxml -XML formatted Cstring to append to DOM object 
// Returns:     long                                         
///////////////////////////////////////////////////////////////////////////////////
long CCollectorBase::WriteReportData(BSTR bxml)//append child to DOM Doc
{
    trace(L7, _T("+CCollectorBase::WriteReportData"));
    BOOL isSuccessful;
    HRESULT hr;
    
    //_bstr_t bxmlString(bxml); // Migrated changes for TAR 387731 into patch G
	_bstr_t bxmlString(bxml, false); // cs185088 mem leak 2012.09.11

   // Next, we will create and add more nodes to the root element 
    if (m_pNewTransacationDOM == NULL)
    {
        hr = CreateDOM();

        if (hr != RPT_OK)
        {
            #ifndef NO_DATACAP
                    trace( L4,
                    _T( "-CCollectorBase::WriteReportData(> HRESULT: %d, RPTERROR_CANTCREATE"), hr );
            #endif

            #ifndef NO_LOGGING
                        LogError(FLR_CREATE_INSTANCE_FAILURE,  (_bstr_t)_T("CCollectorBase::WriteReportData"), EVENTLOG_ERROR_TYPE, hr);
            #endif

            return (hr);
        }
    }


      try
      {
        MSXML2::IXMLDOMDocumentPtr pXMLDom;
        MSXML2::IXMLDOMNodePtr pXMLNode;
        hr = pXMLDom.CreateInstance(__uuidof(MSXML2::DOMDocument60));

        // If the caller wasn't coinitialized, do it now
        if (CO_E_NOTINITIALIZED == hr)
        {   
            hr = CoInitialize(NULL);
            if (!FAILED(hr))
            {
                m_bCoInitialized = true;
                // If at first you don't succeed
                hr = pXMLDom.CreateInstance(__uuidof(MSXML2::DOMDocument60));
            }

        }
        //Make sure that the DOM document object was successfully created
        if (FAILED(hr))
        {
            #ifndef NO_DATACAP
                    trace( L4,
                    _T( "-CCollectorBase::WriteReportData(> HRESULT: %d, RPTERROR_CANTCREATE"), hr );
            #endif

            #ifndef NO_LOGGING
                        LogError(FLR_CREATE_INSTANCE_FAILURE,  (_bstr_t)_T("CCollectorBase::WriteReportData"), EVENTLOG_ERROR_TYPE, hr);
            #endif

            return RPTERROR_CANTCREATE;
        }
    //  Check for valid pointer input
        if (pXMLDom == NULL)
        {
        // Invalid parameter
            #ifndef NO_DATACAP
                    trace( L4,
                    _T( "-CCollectorBase::WriteReportData(> HRESULT: %d, RPT_INVALIDPARM"), hr );
            #endif

            return RPT_INVALIDPARM;
        }
    
        isSuccessful = pXMLDom->loadXML(bxmlString);
        if (isSuccessful)
        {
            //Geting adding node to 1st DOM
            pXMLNode = pXMLDom->GetfirstChild();
            m_pNewTransacationDOM->GetfirstChild()->appendChild(pXMLNode);
			
            //Succesful 
            #ifndef NO_DATACAP
             trace( L7,
             (_bstr_t)_T( "-CCollectorBase::WriteReportData::> S_OK"));
            #endif
            //+TAR 400804
            pXMLDom.Release();
            pXMLDom = NULL;
            pXMLNode.Release();
            pXMLNode = NULL;
            //-TAR 400804
		 
            return RPT_OK;
        }   
        else
        {
            //NOT Succesful 
            #ifndef NO_DATACAP
            trace( L4,
            _T( "-CCollectorBase::WriteReportData::> S_FAIL"));
            #endif
	        //+TAR 400804
            pXMLDom.Release();
            pXMLDom = NULL;
			// Commented out for TAR 440565
			// The node does not get set until the then of the above clause
			// so the release is inappropriate.  
            // pXMLNode.Release();
            // pXMLNode = NULL;
	        //-TAR 400804

            return RPTERROR_CANTLOAD;
        }

      }
        catch (_com_error e)
        {
            #ifndef NO_LOGGING
            _bstr_t errString;
            LogComError(e,  (_bstr_t)_T("CCollectorBase::WriteReportData"));
            #endif
            return RPTERROR_COMEXCEPTION;                           
        }

}

///////////////////////////////////////////////////////////////////////////////
// Function:    TransactionCompleted                                       
// Class:       CCollectorBase                                              
// Description: TransactionCompleted - is a method that is called by the application
//              to indicate that all the data relating to the current transaction has 
//              been completed.  When this event is received from the application, 
//              the current XML file is closed and moved to the directory where the 
//              transporter will see it and move it to the report engine
// Parameters:  csTerminalNumber current terminal number
// Returns:     long                                         
///////////////////////////////////////////////////////////////////////////////////
long CCollectorBase::TransactionCompleted(CString csTerminalNumber)
{
  trace(L7, _T("+CCollectorBase::TransactionCompleted"));
  long lRetCode = RPTERROR_CANTLOAD;
  HRESULT hr;
  SYSTEMTIME sTime; 
  GetSystemTime( &sTime); 
  CString csTime;
  // Fix 318447 - Create unique filenames by using milliseconds.
  csTime.Format(_T("_%.2d%.2d%.2d%.2d%.2d%.2d%.3d"),
                    sTime.wMonth,
                    sTime.wDay,
                    sTime.wYear,
                    sTime.wHour,
                    sTime.wMinute,
                    sTime.wSecond,
					sTime.wMilliseconds);

        CString csTrackingName,csFile,csFileName;
        csTrackingName = csTerminalNumber;
        csFile = csTrackingName + csTime;
        csFileName = REPORTPREFIX + csFile + REPORTENDING;
    if (m_bTransactionCompleted) 
    {
        _bstr_t bstrFileName;
        // Open for business, write the current transacation xml out to a file
		CString l_sStr = REPORTDIRECTORY  + csFileName;

		GET_PARTITION_PATH(l_sStr, l_sStr.GetBuffer(_MAX_PATH));
		l_sStr.ReleaseBuffer();
		bstrFileName = l_sStr;

        //Try catch if don't have the report directory
        try
        {
            if ( !TrainingModeObj.IsTMOn())
            {
                hr = m_pNewTransacationDOM->save(bstrFileName);
                lRetCode = RPT_OK;
                trace( L7,
                _T( "CCollectorBase::TransactionCompleted File created<%s>"), csFileName );
            }

        if (FAILED(hr)) 
        {
            #ifndef NO_DATACAP
            trace( L4,
            _T( "CCollectorBase::TransactionCompleted(> HRESULT: %d, RPTERROR_CANTCREATEFILE"), hr );
            #endif

            #ifndef NO_LOGGING
                        LogError(FLR_LOAD_XML_FAILURE,  (_bstr_t)_T("CCollectorBase::TransactionCompleted"), EVENTLOG_ERROR_TYPE, hr);
            #endif

            return RPTERROR_CANTCREATE;

        }
        else 
        {
         #ifndef NO_DATACAP
         trace( L7,
         _T( "CCollectorBase::TransactionCompleted(> HRESULT: %d, RPT_OK"), hr );
        #endif
        }

        m_pNewTransacationDOM.Release();
        m_bCoInitialized = false;
    

        }
    
        catch (_com_error e)
        {
            #ifndef NO_LOGGING
            _bstr_t errString;
            LogComError(e,  (_bstr_t)_T("CCollectorBase::TransactionCompleted"));
            #endif
            return RPTERROR_CANTCREATE;                           
        }
    }
    //Transport file to Server
    hr = m_Transporter.TransportFiles();

    if (hr != FLRPT_OK)
      {
          #ifndef NO_DATACAP
                 trace( L4,
                 _T( "-CCollectorBase::TransactionCompleted-Cant Transport XML FILE(> HRESULT: %d, RPT_CANTMOVE"), hr );
            #endif
            return (hr);
      }
    
    trace(L7, _T("-CCollectorBase::TransactionCompleted"));
    return lRetCode;
}
//CollectorBase End 
