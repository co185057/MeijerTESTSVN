		[propget, id(DISPID_blocking), helpstring("Determines is methods are blocking."), helpcontext(200)] HRESULT Blocking([out, retval] VARIANT_BOOL *pVal);
		[propput, id(DISPID_blocking), helpstring("Determines is methods are blocking."), helpcontext(200)] HRESULT Blocking([in] VARIANT_BOOL newVal);
		[propget, id(DISPID_debugmode), helpstring("Determines if debug event will be fired."), helpcontext(201)] HRESULT DebugMode([out, retval] VARIANT_BOOL *pVal);
		[propput, id(DISPID_debugmode), helpstring("Determines if debug event will be fired."), helpcontext(201)] HRESULT DebugMode([in] VARIANT_BOOL newVal);
		[propget, id(DISPID_blockingmode), helpstring("Determines type of blocking operation."), helpcontext(202)] HRESULT BlockingMode([out, retval] TelnetXBlockingModesEnum *pVal);
		[propput, id(DISPID_blockingmode), helpstring("Determines type of blocking operation."), helpcontext(202)] HRESULT BlockingMode([in] TelnetXBlockingModesEnum newVal);
		[propget, id(DISPID_host), helpstring("Specifies hostname of remote server."), helpcontext(203)] HRESULT Host([out, retval] BSTR *pVal);
		[propput, id(DISPID_host), helpstring("Specifies hostname of remote server."), helpcontext(203)] HRESULT Host([in] BSTR newVal);
		[propget, id(DISPID_port), helpstring("Specifies port on remote server."), helpcontext(204)] HRESULT Port([out, retval] short *pVal);
		[propput, id(DISPID_port), helpstring("Specifies port on remote server."), helpcontext(204)] HRESULT Port([in] short newVal);
		[propget, id(DISPID_lasterror), helpstring("Holds last error that occurred."), helpcontext(205)] HRESULT LastError([out, retval] short *pVal);
		[propget, id(DISPID_lasterrorstring), helpstring("Holds last error that occurred."), helpcontext(206)] HRESULT LastErrorString([out, retval] BSTR *pVal);
		[propget, id(DISPID_libraryname), helpstring("Holds name of socket stack library."), helpcontext(207)] HRESULT LibraryName([out, retval] BSTR *pVal);
		[propput, id(DISPID_libraryname), helpstring("Holds name of socket stack library."), helpcontext(207)] HRESULT LibraryName([in] BSTR newVal);
		[propget, id(DISPID_state), helpstring("Determines current state of Telnet/X."), helpcontext(208)] HRESULT State([out, retval] TelnetXStatesEnum *pVal);
		[propget, id(DISPID_statestring), helpstring("Returns user-friendly information about a given state."), helpcontext(209)] HRESULT StateString(TelnetXStatesEnum State, [out, retval] BSTR *pVal);
		[propget, id(DISPID_timeout), helpstring("Seconds to elapse before Telnet/X timeouts."), helpcontext(210)] HRESULT Timeout([out, retval] short *pVal);
		[propput, id(DISPID_timeout), helpstring("Seconds to elapse before Telnet/X timeouts."), helpcontext(210)] HRESULT Timeout([in] short newVal);
		[propget, id(DISPID_version), helpstring("Returns version information."), helpcontext(211)] HRESULT Version([out, retval] BSTR *pVal);
		[propput, id(DISPID_version), helpstring("Returns version information."), helpcontext(211)] HRESULT Version([in] BSTR newVal);
		[propget, id(DISPID_localhost), helpstring("Holds name of local computer."), helpcontext(212)] HRESULT LocalHost([out, retval] BSTR *pVal);
		[propput, id(DISPID_localhost), helpstring("Holds name of local computer."), helpcontext(212)] HRESULT LocalHost([in] BSTR newVal);
		[propget, id(DISPID_localip), helpstring("Holds IP address of local computer."), helpcontext(213)] HRESULT LocalIP([out, retval] BSTR *pVal);
		[propput, id(DISPID_localip), helpstring("Holds IP address of local computer."), helpcontext(213)] HRESULT LocalIP([in] BSTR newVal);
		[propget, id(DISPID_firewallhost), helpstring("Specifies hostname of your proxy/firewall server."), helpcontext(214)] HRESULT FirewallHost([out, retval] BSTR *pVal);
		[propput, id(DISPID_firewallhost), helpstring("Specifies hostname of your proxy/firewall server."), helpcontext(214)] HRESULT FirewallHost([in] BSTR newVal);
		[propget, id(DISPID_firewallport), helpstring("Specifies port to be used on proxy/firewall server."), helpcontext(215)] HRESULT FirewallPort([out, retval] short *pVal);
		[propput, id(DISPID_firewallport), helpstring("Specifies port to be used on proxy/firewall server."), helpcontext(215)] HRESULT FirewallPort([in] short newVal);
		[propget, id(DISPID_firewalllogonname), helpstring("Specifies username to be used on proxy/firewall server."), helpcontext(216)] HRESULT FirewallLogonName([out, retval] BSTR *pVal);
		[propput, id(DISPID_firewalllogonname), helpstring("Specifies username to be used on proxy/firewall server."), helpcontext(216)] HRESULT FirewallLogonName([in] BSTR newVal);
		[propget, id(DISPID_firewallpassword), helpstring("Specifies password to be used on proxy/firewall server."), helpcontext(217)] HRESULT FirewallPassword([out, retval] BSTR *pVal);
		[propput, id(DISPID_firewallpassword), helpstring("Specifies password to be used on proxy/firewall server."), helpcontext(217)] HRESULT FirewallPassword([in] BSTR newVal);
		[propget, id(DISPID_firewalltype), helpstring("Specifies type of proxy/firewall used."), helpcontext(218)] HRESULT FirewallType([out, retval] FirewallTypeEnum *pVal);
		[propput, id(DISPID_firewalltype), helpstring("Specifies type of proxy/firewall used."), helpcontext(218)] HRESULT FirewallType([in] FirewallTypeEnum newVal);
		[propget, id(DISPID_autologon), helpstring("Determines if Telnet/X will automatically logon to server."), helpcontext(219)] HRESULT AutoLogon([out, retval] VARIANT_BOOL *pVal);
		[propput, id(DISPID_autologon), helpstring("Determines if Telnet/X will automatically logon to server."), helpcontext(219)] HRESULT AutoLogon([in] VARIANT_BOOL newVal);
		[propget, id(DISPID_logonname), helpstring("Holds username for autologon."), helpcontext(220)] HRESULT LogonName([out, retval] BSTR *pVal);
		[propput, id(DISPID_logonname), helpstring("Holds username for autologon."), helpcontext(220)] HRESULT LogonName([in] BSTR newVal);
		[propget, id(DISPID_logonpassword), helpstring("Holds password for autologon."), helpcontext(221)] HRESULT LogonPassword([out, retval] BSTR *pVal);
		[propput, id(DISPID_logonpassword), helpstring("Holds password for autologon."), helpcontext(221)] HRESULT LogonPassword([in] BSTR newVal);
		[propget, id(DISPID_logoncommand), helpstring("Holds initial command send to server after autologon."), helpcontext(222)] HRESULT LogonCommand([out, retval] BSTR *pVal);
		[propput, id(DISPID_logoncommand), helpstring("Holds initial command send to server after autologon."), helpcontext(222)] HRESULT LogonCommand([in] BSTR newVal);
		[propget, id(DISPID_prompt), helpstring("Determines remote prompt that is expected from server."), helpcontext(223)] HRESULT PromptString([out, retval] BSTR *pVal);
		[propput, id(DISPID_prompt), helpstring("Determines remote prompt that is expected from server."), helpcontext(223)] HRESULT PromptString([in] BSTR newVal);
		[propget, id(DISPID_protocol), helpstring("Determines protocol used with remote server."), helpcontext(224)] HRESULT Protocol([out, retval] ProtocolsEnum *pVal);
		[propput, id(DISPID_protocol), helpstring("Determines protocol used with remote server."), helpcontext(224)] HRESULT Protocol([in] ProtocolsEnum newVal);
		[propget, id(DISPID_encryption), helpstring("Determines encryption algorithm used for SSH."), helpcontext(225)] HRESULT Encryption([out, retval] EncryptionsEnum *pVal);
		[propput, id(DISPID_encryption), helpstring("Determines encryption algorithm used for SSH."), helpcontext(225)] HRESULT Encryption([in] EncryptionsEnum newVal);
		[propget, id(DISPID_terminalname), helpstring("Specifies name of terminal reported to remote server."), helpcontext(226)] HRESULT TerminalName([out, retval] BSTR *pVal);
		[propput, id(DISPID_terminalname), helpstring("Specifies name of terminal reported to remote server."), helpcontext(226)] HRESULT TerminalName([in] BSTR newVal);
		[propget, id(DISPID_terminaltype), helpstring("Determines if Telnet/X will try to negotiate options with remote Telnet server."), helpcontext(227)] HRESULT TerminalType([out, retval] TelnetXTypesEnum *pVal);
		[propput, id(DISPID_terminaltype), helpstring("Determines if Telnet/X will try to negotiate options with remote Telnet server."), helpcontext(227)] HRESULT TerminalType([in] TelnetXTypesEnum newVal);
		[propget, id(DISPID_licensekey), helpstring("Holds License Key information."), helpcontext(228)] HRESULT LicenseKey([out, retval] BSTR *pVal);
		[propput, id(DISPID_licensekey), helpstring("Holds License Key information."), helpcontext(228)] HRESULT LicenseKey([in] BSTR newVal);
		[id(DISPID_ABOUTBOX), helpstring("Displays about box."), helpcontext(229)] HRESULT About();
		[id(DISPID_connect), helpstring("Connects to remote server."), helpcontext(230)] HRESULT Connect([in, optional] VARIANT Host, [in, optional] VARIANT Port);
		[id(DISPID_disconnect), helpstring("Disconnects from remote server."), helpcontext(231)] HRESULT Disconnect();
		[id(DISPID_receive), helpstring("Reads data received from remote server."), helpcontext(232)] HRESULT Receive([in, optional] VARIANT Type, [in,optional] VARIANT Count,  [out, retval] VARIANT *retval);
		[id(DISPID_send), helpstring("Sends data to remote server."), helpcontext(233)] HRESULT Send(VARIANT Data, [out, retval] short *retcount);
