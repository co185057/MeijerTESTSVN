///////////////////////////////////////////////////////////////////////////
///
/// \file BaseMsgMap.h
/// \brief Interface for the CMsgHandler class
///
// POS320135 Work Request:76936 Name:Alex Bronola Date:April 3, 2017
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BaseMsgMap_H__INCLUDED_)
#define AFX_BaseMsgMap_H__INCLUDED_

#include "tbMessageMap.h"
#include "MsgHandler.h"
#include "BaseCurrentTransaction.h"
#include "TBUtilities.h"

#pragma warning (disable: 4786)
#pragma warning (disable: 4788)
#include <map>
#include <list>
using namespace std;


#define     cSTATE_ANY   -1
#define     cMSG_ANY    _T("-1")

#define     MAX_FUNCTION_LOOKUP 150 

class CMsgMapNode;
class CBaseMsgMap;

typedef bool (CBaseMsgMap::*tMethodPointer)(TBSTATE &retval, LPARAM lparam);

typedef map<CString, tMethodPointer> CMapNameToMethodPointer;

typedef pair<tMethodPointer, LPARAM> MsgHandlerPair;
typedef vector<MsgHandlerPair> MsgHandlerPairList;
typedef MsgHandlerPairList::iterator MsgHandlerPairListIterator;

//typedef struct{
//    LPCTSTR szMethodName;
//    tMethodPointer pmsgHandler;
//} tFunctionLookup;

/// \def ADD_HANDLER is defined as HandlerFN(TBSTATE, LPARAM) method
#define ADD_HANDLER(HandlerFn)         bool HandlerFn(TBSTATE &tbretState, LPARAM lparam);

//#define ADD_HANDLERLOOKUP(classname,HandlerFn)   AddHandlerLookup("##HandlerFn ##", (tMethodPointer) &##classname::##HandlerFn);

//////////////////////////////////////////////////////////////////////
///
/// CMsgMapNode is a Helper class that manage the TBState information.
///
///	@author:
///
//////////////////////////////////////////////////////////////////////
class CMsgMapNode
{
public:
    int currentState;
    TCHAR * pmsg;
    CString csTrace;
    
		int newProgressState;  ///< updates CurrentInProgressState before calling the handler 
    
		TBSTATE tbretState;    ///< return state, set and passed into handler by reference 
													 ///< can override in handler
		
		// single handler/param pair replaced by a dynamic list, allowing a map entry to have
		// multiple actionable items instead
		MsgHandlerPairList msgHandlers;

    CMsgMapNode():
    currentState(0),
        pmsg(NULL),
        newProgressState(0),
        tbretState((TBSTATE)0)
        {
            csTrace = _T("");
            msgHandlers.clear();
		};
    ~CMsgMapNode()
    {
        delete [] pmsg;

		while( !msgHandlers.empty() )
        {
            MsgHandlerPair & handler = msgHandlers.back();
            if( handler.second ) 
            {
                delete [] (LPTSTR) handler.second;
            }
            msgHandlers.pop_back();
        }
    }
} ;



//////////////////////////////////////////////////////////////////////
///
/// CBaseMsgMap is ...
///
///	@author: FastLane POSI
///
//////////////////////////////////////////////////////////////////////
class CBaseMsgMap : public CMsgHandler  
{
public:
		//////////////////////////////////////////////////////////////////////
		///
		/// Destructor
		///
		//////////////////////////////////////////////////////////////////////
    virtual ~CBaseMsgMap();
    
		//////////////////////////////////////////////////////////////////////
		///
		/// Initialize(), ...
		///
		//////////////////////////////////////////////////////////////////////
    virtual void Initialize();
    
		//////////////////////////////////////////////////////////////////////
		///
		/// ClearUnhandledMessageWatchdog()
		///
		//////////////////////////////////////////////////////////////////////
    void ClearUnhandledMessageWatchdog();

		//////////////////////////////////////////////////////////////////////
		///
		/// SetDelayedTriggerHandler
		///
		///	@param DWORD dwDelay
		//////////////////////////////////////////////////////////////////////
    void SetDelayedTriggerHandler(DWORD dwDelay);

		//////////////////////////////////////////////////////////////////////
		///
		/// msgUnhandledMessage
		///
		///	@param TBSTATE - returnState
		/// @param LPARAM - param
		///	@return bool
		//////////////////////////////////////////////////////////////////////
    virtual bool msgUnhandledMessage(TBSTATE &tbretState, LPARAM lparam);

		//////////////////////////////////////////////////////////////////////
		///
		/// HandleMessageMatch
		///
		///	@param CMsgMapNode
		///	@return long
		//////////////////////////////////////////////////////////////////////
    virtual long HandleMessageMatch(CMsgMapNode *pEntry);

		//////////////////////////////////////////////////////////////////////
		///
		/// dispatchHelper
		///
		///	@param CString csMessage
		///	@return TBSTATE
		//////////////////////////////////////////////////////////////////////
    virtual TBSTATE dispatchHelper(const CString &csMessage);

		//////////////////////////////////////////////////////////////////////
		///
		/// dispatchMsgHandler looks for the message match. Entries may be
		/// for the specific text string passed in or for any message for
		/// a specific state. Slip, journal, receipt, 2x20, and display can all
		/// be handled the same.
		///
		/// @param CString  str -- input device message
		/// @return TBState to return to FastLane
		///
		//////////////////////////////////////////////////////////////////////
    virtual TBSTATE dispatchMsgHandler(const CString &csMessage1);

		//////////////////////////////////////////////////////////////////////
		///
		/// TriggerMsgMap
		///
		//////////////////////////////////////////////////////////////////////
    void TriggerMsgMap();
		
		//////////////////////////////////////////////////////////////////////
		///
		/// UnhandledMessageWatchdogProc
		///
		///	@param HWND hwnd
		///	@param UINT uMsg
		///	@param UINT_PTR idEvent
		/// @param DWORD dwTime
		//////////////////////////////////////////////////////////////////////
    friend VOID CALLBACK UnhandledMessageWatchdogProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

		//////////////////////////////////////////////////////////////////////
		///
		/// DelayedTriggerHandlerProc
		///
		///	@param HWND hwnd
		///	@param UINT uMsg
		///	@param UINT_PTR idEvent
		/// @param DWORD dwTime
		//////////////////////////////////////////////////////////////////////
    friend VOID CALLBACK DelayedTriggerHandlerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

		//////////////////////////////////////////////////////////////////////
		///
		/// SetUnhandledMessageWatchdog
		///
		//////////////////////////////////////////////////////////////////////
    void SetUnhandledMessageWatchdog();

		//////////////////////////////////////////////////////////////////////
		///
		/// ClearDelayedTriggerHandler
		///
		//////////////////////////////////////////////////////////////////////
    void ClearDelayedTriggerHandler();

		//////////////////////////////////////////////////////////////////////
		///
		/// SetupMessageScreen
		///
		///	@int
		///	@int
		///	@LPCTSTR
		///	@bool
		///	@bool
		//////////////////////////////////////////////////////////////////////
    void SetupMessageScreen(int, int, LPCTSTR, bool, bool);

		//////////////////////////////////////////////////////////////////////
		///
		/// msgMessageScreen
		///
		/// @param TBSTATE
		///	@param LPARAM
		///	@return bool
		//////////////////////////////////////////////////////////////////////
    bool msgMessageScreen(TBSTATE &tbretState, LPARAM lparam);

		//////////////////////////////////////////////////////////////////////
		///
		/// msgSetFLState
		///
		///	@param TBSTATE
		///	@param LPARAM
		///	@return bool
		//////////////////////////////////////////////////////////////////////
    bool msgSetFLState(TBSTATE &tbretState, LPARAM lparam);

		//////////////////////////////////////////////////////////////////////
		///
		/// msgSendReturnStatusMsgs
		///
		///	@param TBSTATE
		///	@param LPARAM
		///	@return bool
		//////////////////////////////////////////////////////////////////////
    bool msgSendReturnStatusMsgs(TBSTATE &tbretState, LPARAM lparam);

		//////////////////////////////////////////////////////////////////////
		///
		/// msgDataNeeded
		///
		///	@param TBSTATE
		///	@param LPARAM
		///	@return bool
		//////////////////////////////////////////////////////////////////////
    bool msgDataNeeded(TBSTATE &tbretState, LPARAM lparam);

		//////////////////////////////////////////////////////////////////////
		///
		/// msgAddLineToRAP
		///
		///	@param TBSTATE
		/// @param LPARAM
		///	@return bool
		//////////////////////////////////////////////////////////////////////
    bool msgAddLineToRAP(TBSTATE &tbretState, LPARAM lparam);

		//////////////////////////////////////////////////////////////////////
		///
		/// msgSendSequence
		///
		///	@param TBSTATE
		/// @param LPARAM
		///	@return bool
		//////////////////////////////////////////////////////////////////////
    bool msgSendSequence(TBSTATE &tbretState, LPARAM lparam);

		//////////////////////////////////////////////////////////////////////
		///
		/// msgSetProperty
		///
		///	@param TBSTATE
		/// @param LPARAM
		///	@return bool
		//////////////////////////////////////////////////////////////////////
		bool msgSetProperty(TBSTATE &tbretState, LPARAM lparam);

		//////////////////////////////////////////////////////////////////////
		///
		/// ProcessMessage
		///
		///	@param CTBMsgObj
		///	@return TBSTATE
		//////////////////////////////////////////////////////////////////////
    virtual TBSTATE ProcessMessage(CTBMsgObj *pMsgObj=NULL);

		//////////////////////////////////////////////////////////////////////
		///
		/// msgAPI_Finish
		///
		///	@param TBSTATE
		/// @param LPARAM
		///	@return bool
		//////////////////////////////////////////////////////////////////////
		virtual bool msgAPI_Finish(TBSTATE &tbretState, LPARAM lparam);
		
		//////////////////////////////////////////////////////////////////////
		///
		/// msgOverridePOSState
		///
		///	@param TBSTATE
		/// @param LPARAM
		///	@return bool
		//////////////////////////////////////////////////////////////////////
	virtual bool msgOverridePOSState(TBSTATE &tbretState, LPARAM lparam);


protected:

		//////////////////////////////////////////////////////////////////////
		///
		/// Destructor
		///
		//////////////////////////////////////////////////////////////////////
    CBaseMsgMap();

		//////////////////////////////////////////////////////////////////////
		///
		/// Initialize
		///
		///	@param CMsgMapNode
		///	@param int
		//////////////////////////////////////////////////////////////////////
    virtual void  Initialize(CMsgMapNode *pmap, int count);
    
		/////////////////////////////////////////////////////////////////////
		/// CurrentTransactionObject
		/////////////////////////////////////////////////////////////////////
    CBaseCurrentTransaction *m_pCurrTrx; 
    
		bool m_bmsgHandled;	///< bool if message has been handled

		/////////////////////////////////////////////////////////////////////
		/// CurrentTransactionObject
		/////////////////////////////////////////////////////////////////////
    CtbMessageMap<CMsgMapNode>    *m_pmmGeneric;
    
		/////////////////////////////////////////////////////////////////////
		/// UnhandledMessageWatchdog integer ptr
		/////////////////////////////////////////////////////////////////////
    UINT_PTR m_hUnhandledMessageWatchdog;

		/////////////////////////////////////////////////////////////////////
		/// UnhandledMessageWatchdog critical section
		/////////////////////////////////////////////////////////////////////
    CRITICAL_SECTION m_csUnhandledMessageWatchdog;
    
		/////////////////////////////////////////////////////////////////////
		/// m_hDelayedTriggerHandler integer ptr
		/////////////////////////////////////////////////////////////////////
		UINT_PTR m_hDelayedTriggerHandler;

		/////////////////////////////////////////////////////////////////////
		/// m_hDelayedTriggerHandler critical section
		/////////////////////////////////////////////////////////////////////
    CRITICAL_SECTION m_csDelayedTriggerHandler;

		//////////////////////////////////////////////////////////////////////
		///
		/// InitXMLDoc
		///
		//////////////////////////////////////////////////////////////////////
    void InitXMLDoc();

		//////////////////////////////////////////////////////////////////////
		///
		/// LookupHandlers
		///
		//////////////////////////////////////////////////////////////////////
    virtual void LookupHandlers();

		//////////////////////////////////////////////////////////////////////
		///
		/// AddHandlerLookup
		///
		/// @param LPCTSTR
		///	@param tMethodPointer
		//////////////////////////////////////////////////////////////////////
    void AddHandlerLookup(LPCTSTR methodname, tMethodPointer methodPtr);

private:
		//////////////////////////////////////////////////////////////////////
		///
		/// Copy constant
		///
		//////////////////////////////////////////////////////////////////////
    CBaseMsgMap(const CBaseMsgMap &);                 
    
		//////////////////////////////////////////////////////////////////////
		///
		/// Equal assignment
		///
		//////////////////////////////////////////////////////////////////////
		CBaseMsgMap& operator=(const CBaseMsgMap &);

		//////////////////////////////////////////////////////////////////////
		///
		/// ParseParamString
		///
		///	@param CString
		///	@param LPCTSTR
		///	@param LPCTSTR
		//////////////////////////////////////////////////////////////////////
    void ParseParamString(CString &csStr, LPCTSTR szStartDelim, LPCTSTR szStopDelim);

		/////////////////////////////////////////////////////////////////////
		/// MessageMapNode Pointer
		/////////////////////////////////////////////////////////////////////
    CMsgMapNode *m_pmsgMapList;

		/////////////////////////////////////////////////////////////////////
		/// Interface to XML DOM pointer
		/////////////////////////////////////////////////////////////////////
    MSXML2::IXMLDOMDocument2Ptr m_pMsgDoc;

		//////////////////////////////////////////////////////////////////////
		///
		/// GetMethodPointer
		///
		///	@param LPCTSTR
		/// @return tMethodPointer
		//////////////////////////////////////////////////////////////////////
    tMethodPointer GetMethodPointer(LPCTSTR szMethodName);
		
		/////////////////////////////////////////////////////////////////////
		/// MethodPointer
		/////////////////////////////////////////////////////////////////////
    CMapNameToMethodPointer m_FunctionLookup;

		/////////////////////////////////////////////////////////////////////
		/// Last Saved POS State
		/////////////////////////////////////////////////////////////////////
    CString m_csSavedLastPosState;

		/////////////////////////////////////////////////////////////////////
		/// MsgMap pointer
		/////////////////////////////////////////////////////////////////////
    static CBaseMsgMap* m_pThis;
#ifdef _DEBUG
private:

		/////////////////////////////////////////////////////////////////////
		/// Interface to XML DOM pointer
		/////////////////////////////////////////////////////////////////////
    MSXML2::IXMLDOMDocumentPtr m_spMapUsage;
#endif

};

#endif // !defined(AFX_MSGHANDLER_H__13E6EF24_87EC_46DC_ABED_74BEAD7C8094__INCLUDED_)
